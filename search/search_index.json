{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Programming Repository","text":""},{"location":"#contents","title":"Contents","text":"<ul> <li>July 29 - 2025 Programs</li> </ul>"},{"location":"#assignment","title":"Assignment","text":"<ul> <li>Assignment 1</li> </ul>"},{"location":"#homework","title":"Homework","text":"<ul> <li>Homework 1</li> </ul>"},{"location":"#notes","title":"Notes","text":"<ul> <li>Data Types</li> </ul>"},{"location":"#section-1","title":"Section 1","text":"<ul> <li>Chapter 1 : Literals And Variables</li> <li>Chapter 2 : Operators</li> <li>Chapter 3 : Arithemetic Operators</li> <li>Chapter 4 : Strings</li> </ul>"},{"location":"#section-2","title":"Section 2","text":"<ul> <li>Chapter 1 : Variables</li> <li>Chapter 2 : Input</li> <li>Chapter 3 : Conditional Statements</li> </ul>"},{"location":"#section-3","title":"Section 3","text":"<ul> <li>Chapter 1 : Loops Part 1</li> <li>Chapter 2 : Loops Part 2</li> <li>Chapter 3 : Nested Loops</li> <li>Chapter 4 : Formatted Printing</li> </ul>"},{"location":"#section-4","title":"Section 4","text":"<ul> <li>Chapter 1 : Functions</li> <li>Chapter 2 : Arguments</li> <li>Chapter 3 : Scope</li> <li>Chapter 4 : Function Calling</li> </ul>"},{"location":"#section-5","title":"Section 5","text":"<ul> <li>Chapter 1 : Lists Part 1</li> <li>Chapter 2 : Lists Part 2</li> <li>Chapter 3 : Lists Part Methods</li> <li>Chapter 4 : List Methods</li> <li>Chapter 5 : Tuples</li> </ul>"},{"location":"Theory/","title":"Theory Questions","text":""},{"location":"Theory/#1-what-is-python","title":"1. What Is Python ?","text":"<p>Python is a high-level, interpreted programming language known for its simplicity and readability.</p> <p>It supports multiple programming paradigms, including procedural, object-oriented, and functional programming.</p> <p>Python is widely used in various domains such as web development, data analysis, artificial intelligence, scientific computing, and automation.</p>"},{"location":"Theory/#2-what-is-high-level-language-why-is-python-a-high-level-language","title":"2. What Is High Level Language ? Why Is Python a High-Level Language ?","text":"<p>High-level languages are programming languages that are designed to be easy for humans to read and write.</p> <p>Python is a high-level programming language because it is easy to read and write. It lets you focus on solving problems instead of worrying about hardware details or memory management.</p>"},{"location":"Theory/#3-what-is-interpreted-language-why-python-is-interpreted-language","title":"3. What Is Interpreted Language ? Why Python Is Interpreted Language ?","text":"<p>An interpreted language is a type of programming language for which most of the instructions are executed directly, without the need for a compiler to convert the code into machine-level instructions.</p> <p>It executes code line by line at runtime, which allows for more flexibility and easier debugging.</p> <p>Python is considered an interpreted language because Python code is executed line by line by the</p> <p>Python interpreter, which means you can run Python code without the need for a separate compilation step.</p>"},{"location":"Theory/#4-why-we-use-python-over-c-c-java","title":"4. Why We Use Python Over C / C++ / Java ?","text":"<p>Python is often preferred over C, C++, or Java for several reasons:</p> <ol> <li> <p>Python has a simpler and more readable syntax, which makes it easier to learn and write code quickly.</p> </li> <li> <p>Python has a large standard library and a vast ecosystem of third-party libraries, which allows for rapid development and prototyping.</p> </li> <li> <p>Python is dynamically typed, which means you don't need to declare variable types explicitly, making it more flexible.</p> </li> <li> <p>Python supports multiple programming paradigms, including procedural, object-oriented, and functional programming.</p> </li> <li> <p>Python has a strong community and extensive documentation, making it easier to find help and resources.</p> </li> <li> <p>Python is cross-platform, meaning it can run on various operating systems without modification.</p> </li> </ol>"},{"location":"29-07-2025/","title":"Programming Exercises - July 29, 2025","text":""},{"location":"29-07-2025/#exercise-1-write-a-program-to-find-the-sum-of-all-the-elements-in-a-list","title":"Exercise 1 : Write A Program To Find The Sum Of All The Elements In A List","text":"<pre><code>finalList = []\nnumOfElements = int(input(\"Enter The Number Of Elements In The List : \"))\n\nfor i in range(numOfElements):\n    element = int(input(\"Enter The Element : \"))\n    finalList.append(element)\n\nprint(\"The List Is : \", finalList)\nprint(\"The Sum Of Elements : \", sum(finalList))\n</code></pre>"},{"location":"29-07-2025/#exercise-2-write-a-program-to-find-the-maximum-and-minimum-element-in-a-list","title":"Exercise 2 : Write A Program To Find The Maximum And Minimum Element In A List","text":"<pre><code>finalList = []\nnumOfElements = int(input(\"Enter The Number Of Elements In The List : \"))\n\nfor i in range(numOfElements):\n    element = int(input(\"Enter The Element : \"))\n    finalList.append(element)\n\nprint(\"The List Is : \", finalList)\nprint(\"The Maximum Element : \", max(finalList))\nprint(\"The Minimum Element : \", min(finalList))\n</code></pre>"},{"location":"29-07-2025/#write-a-program-to-print-the-number-of-particular-element-in-a-list","title":"Write A Program To Print The Number Of Particular Element In A List","text":"<pre><code>finalList = []\nnumOfElements = int(input(\"Enter The Number Of Elements In The List : \"))\n\nfor i in range(numOfElements):\n    element = int(input(\"Enter The Element : \"))\n    finalList.append(element)\n\nprint(\"The List Is : \", finalList)\n\nelementToCount = int(input(\"Enter The Element To Count : \"))\nprint(\"The Count Of Element\", elementToCount, \"In The List Is : \", finalList.count(elementToCount))\n</code></pre>"},{"location":"29-07-2025/#write-a-program-to-remove-duplicates-from-a-list","title":"Write A Program To Remove Duplicates From A List","text":"<pre><code>finalList = []\nnumOfElements = int(input(\"Enter The Number Of Elements In The List : \"))\n\nfor i in range(numOfElements):\n    element = int(input(\"Enter The Element : \"))\n    finalList.append(element)\n\nprint(\"The List Is : \", finalList)\nfinalList = list(set(finalList))\n\nprint(\"The List After Removing Duplicates : \", finalList)\n</code></pre>"},{"location":"29-07-2025/#write-a-program-to-reverse-a-list","title":"Write A Program To Reverse A List","text":"<pre><code>finalList = []\nnumOfElements = int(input(\"Enter The Number Of Elements In The List : \"))\n\nfor i in range(numOfElements):\n    element = int(input(\"Enter The Element : \"))\n    finalList.append(element)\n\nprint(\"The List Is : \", finalList)\n\nfinalList.reverse()\nprint(\"The List After Reversing : \", finalList)\n</code></pre>"},{"location":"29-07-2025/#write-a-program-to-sort-a-list","title":"Write A Program To Sort A List","text":"<pre><code>finalList = []\nnumOfElements = int(input(\"Enter The Number Of Elements In The List : \"))\n\nfor i in range(numOfElements):\n    element = int(input(\"Enter The Element : \"))\n    finalList.append(element)\n\nprint(\"The List Is : \", finalList)\n\nfinalList.sort()\nprint(\"The List After Sorting : \", finalList)\n</code></pre>"},{"location":"29-07-2025/#write-a-program-to-merge-two-lists","title":"Write A Program To Merge Two Lists","text":"<pre><code>finalList1 = []\nnumOfElements1 = int(input(\"Enter The Number Of Elements In The First List : \"))\n\nfor i in range(numOfElements1):\n    element = int(input(\"Enter The Element : \"))\n    finalList1.append(element)\n\nfinalList2 = []\nnumOfElements2 = int(input(\"Enter The Number Of Elements In The Second List : \"))\n\nfor i in range(numOfElements2):\n    element = int(input(\"Enter The Element : \"))\n    finalList2.append(element)\n\nprint(\"The First List Is : \", finalList1)\nprint(\"The Second List Is : \", finalList2)\n\nfinalList1.extend(finalList2)\nprint(\"The Merged List Is : \", finalList1)\n</code></pre>"},{"location":"Assignment/Assignment%201/","title":"Programming Assignment 1","text":""},{"location":"Assignment/Assignment%201/#exercise-1-write-a-python-program-to-print-hello-world","title":"Exercise 1: Write a Python program to print \"Hello World\"","text":"<pre><code>print(\"Hello World\")\n</code></pre>"},{"location":"Assignment/Assignment%201/#output","title":"OUTPUT","text":"<pre><code>Hello World\n</code></pre>"},{"location":"Assignment/Assignment%201/#exercise-2-write-a-program-to-take-2-values-from-user-sum-them-print-the-result","title":"Exercise 2: Write a program to take 2 values from user, sum them, print the result","text":"<pre><code>number1 = int(input(\"Enter Number 1 : \"))\nnumber2 = int(input(\"Enter Number 2 : \"))\nprint(f\"Sum Of {number1} And {number2} Is {number1 + number2}\")\n</code></pre>"},{"location":"Assignment/Assignment%201/#output_1","title":"OUTPUT","text":"<pre><code>Enter Number 1 : 5\nEnter Number 2 : 5\nSum Of 5 And 5 Is 10\n</code></pre>"},{"location":"Assignment/Assignment%201/#exercise-3-demonstrate-id-type-sep-end-bitwise-operators","title":"Exercise 3: Demonstrate <code>id()</code>, <code>type()</code>, <code>sep</code>, <code>end</code>, bitwise operators (<code>|</code>, <code>&amp;</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>)","text":"<pre><code># User Input\na = int(input(\"Enter A Number : \"))\nb = float(input(\"Enter A Float :\"))\nc = str(input(\"Enter A String : \"))\n\nprint(\"ID Of a :\", id(a), \"Type Of a :\", type(a))\nprint(\"ID Of b :\", id(b), \"Type Of b :\", type(b))\nprint(\"ID Of c :\", id(c), \"Type Of c :\", type(c))\n\n# Sep And End Parameters\nprint(\"Python\", \"is\", \"fun\", sep=\"-\", end=\"!\\n\")\n\n# Bitwise Operators\nx = 5  # 0b0101\ny = 3  # 0b0011\n\nprint(\"x | y =\", x | y)  # Bitwise OR\nprint(\"x &amp; y =\", x &amp; y)  # Bitwise AND\nprint(\"x ^ y =\", x ^ y)  # Bitwise XOR\n\nprint(\"x &lt;&lt; 1 =\", x &lt;&lt; 1)  # Left shift\nprint(\"x &gt;&gt; 1 =\", x &gt;&gt; 1)  # Right shift\n</code></pre>"},{"location":"Assignment/Assignment%201/#output_2","title":"OUTPUT","text":"<pre><code>Enter A Number : 2\nEnter A Float :3.33\nEnter A String : SOHAM\nID Of a : 139892576275760 Type Of a : &lt;class 'int'&gt;\nID Of b : 139892333066416 Type Of b : &lt;class 'float'&gt;\nID Of c : 139892332575600 Type Of c : &lt;class 'str'&gt;\nPython-is-fun!\nx | y = 7\nx &amp; y = 1\nx ^ y = 6\nx &lt;&lt; 1 = 10\nx &gt;&gt; 1 = 2\n</code></pre>"},{"location":"Assignment/Assignment%201/#exercise-4-write-a-program-for-net-amount-payable-on-purchasing-electronic-goods","title":"Exercise 4: Write a program for net amount payable on purchasing Electronic goods","text":"<ul> <li>If Cost &gt;= 50000: discount 15%</li> <li>If Cost between 30000 to 50000: discount 10%</li> <li>If Cost between 20000 to 30000: discount 5%</li> </ul> <pre><code>cost = int(input(\"Enter The Cost Of Electronic Goods : \"))\n\nif cost &gt;= 50000:\n    discount = cost * 0.15\n    print(\"The Discounted Price Is : \", cost - discount)\nelif 30000 &lt;= cost &lt; 50000:\n    discount = cost * 0.10\n    print(\"The Discounted Price Is : \", cost - discount)\nelif 20000 &lt;= cost &lt; 30000:\n    discount = cost * 0.05\n    print(\"The Discounted Price Is : \", cost - discount)\nelse:\n    print(\"No Discount Available!\")\n</code></pre>"},{"location":"Assignment/Assignment%201/#output_3","title":"OUTPUT","text":"<p>```bash Enter The Cost Of Electronic Goods : 32000 The Discounted Price Is :  28800.0</p>"},{"location":"Homework/Homework%201/","title":"Programming Assignment: Homework 1 (List Operations)","text":""},{"location":"Homework/Homework%201/#program-1-find-the-sum-of-all-elements-in-a-list","title":"Program 1: Find the Sum of All Elements in a List","text":"<pre><code>lst = [1, 2, 3, 4, 5]\nsum_of_elements = sum(lst)\n\nprint(\"The Sum of All Elements : \", sum_of_elements)\n</code></pre> <p>Sample Output:</p> <pre><code>The Sum of All Elements :  15\n</code></pre>"},{"location":"Homework/Homework%201/#program-2-find-the-maximum-element-in-a-list","title":"Program 2: Find the Maximum Element in a List","text":"<pre><code>lst = [1, 2, 3, 4, 5]\nmax_element = max(lst)\n\nprint(\"The Maximum Element : \", max_element)\n</code></pre> <p>Sample Output:</p> <pre><code>The Maximum Element :  5\n</code></pre>"},{"location":"Homework/Homework%201/#program-3-count-how-many-times-an-element-occurs-in-a-list","title":"Program 3: Count How Many Times an Element Occurs in a List","text":"<pre><code>lst = [1, 2, 3, 4, 5, 3, 2, 1]\n\nelement_to_count = 3\ncount_of_element = lst.count(element_to_count)\n\nprint(f\"The Element {element_to_count} Occurs : \", count_of_element)\n</code></pre> <p>Sample Output:</p> <pre><code>The Element 3 Occurs :  2\n</code></pre>"},{"location":"Homework/Homework%201/#program-4-remove-duplicates-from-a-list","title":"Program 4: Remove Duplicates from a List","text":"<pre><code>lst = [1, 2, 3, 4, 5, 3, 2, 1]\nunique_elements = list(set(lst))\n\nprint(\"List After Removing Duplicates : \", unique_elements)\n</code></pre> <p>Sample Output:</p> <pre><code>List After Removing Duplicates :  [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"Homework/Homework%201/#program-5-reverse-a-list","title":"Program 5: Reverse a List","text":"<pre><code>lst = [1, 2, 3, 4, 5]\nreversed_list = lst[::-1]\n\nprint(\"Reversed List : \", reversed_list)\n</code></pre> <p>Sample Output:</p> <pre><code>Reversed List :  [5, 4, 3, 2, 1]\n</code></pre>"},{"location":"Homework/Homework%201/#program-6-print-list-in-sorted-order","title":"Program 6: Print List in Sorted Order","text":"<pre><code>lst = [5, 3, 1, 4, 2]\nsorted_list = sorted(lst)\n\nprint(\"Sorted List : \", sorted_list)\n</code></pre> <p>Sample Output:</p> <pre><code>Sorted List :  [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"Homework/Homework%201/#program-7-merge-two-lists","title":"Program 7: Merge Two Lists","text":"<pre><code>list1 = [1, 2, 3]\nlist2 = [4, 5, 6]\n\nmerged_list = list1 + list2\n\nprint(\"Merged List : \", merged_list)\n</code></pre> <p>Sample Output:</p> <pre><code>Merged List :  [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"Notes/DataTypes/","title":"Data Types In Python","text":"In\u00a0[3]: Copied! <pre># Integer (int)\na = 10\nprint('Original a:', a)\n\na = a + 5  # This Creates a New Integer Object\nprint('Modified a:', a)\n\n# String (str)\ns = \"hello\"\nprint('Original s:', s)\ntry:\n    s[0] = 'H'  # This Will Raise An Error\nexcept TypeError as e:\n    print('Error:', e)\n\n# Tuple\nt = (1, 2, 3)\nprint('Original tuple:', t)\ntry:\n    t[0] = 10  # This Will Raise An Error\nexcept TypeError as e:\n    print('Error:', e)\n</pre> # Integer (int) a = 10 print('Original a:', a)  a = a + 5  # This Creates a New Integer Object print('Modified a:', a)  # String (str) s = \"hello\" print('Original s:', s) try:     s[0] = 'H'  # This Will Raise An Error except TypeError as e:     print('Error:', e)  # Tuple t = (1, 2, 3) print('Original tuple:', t) try:     t[0] = 10  # This Will Raise An Error except TypeError as e:     print('Error:', e)  <pre>Original a: 10\nModified a: 15\nOriginal s: hello\nError: 'str' object does not support item assignment\nOriginal tuple: (1, 2, 3)\nError: 'tuple' object does not support item assignment\n</pre> In\u00a0[\u00a0]: Copied! <pre># List\nlst = [1, 2, 3]\nprint('Original list:', lst)\n\nlst[0] = 10  # Modifies The List In Place\nprint('Modified list:', lst)\n\n# Dictionary\nd = {'a': 1, 'b': 2}\nprint('Original dict:', d)\n\nd['a'] = 100  # Modifies The Dictionary In Place\nprint('Modified dict:', d)\n\n# Set\ns = {1, 2, 3}\nprint('Original set:', s)\n\ns.add(4)  # Modifies The Set In Place\nprint('Modified set:', s)\n</pre> # List lst = [1, 2, 3] print('Original list:', lst)  lst[0] = 10  # Modifies The List In Place print('Modified list:', lst)  # Dictionary d = {'a': 1, 'b': 2} print('Original dict:', d)  d['a'] = 100  # Modifies The Dictionary In Place print('Modified dict:', d)  # Set s = {1, 2, 3} print('Original set:', s)  s.add(4)  # Modifies The Set In Place print('Modified set:', s)"},{"location":"Notes/DataTypes/#data-types-in-python","title":"Data Types In Python\u00b6","text":""},{"location":"Notes/DataTypes/#immutable-data-types","title":"Immutable Data Types\u00b6","text":"<p>Immutable data types are types whose values cannot be changed after they are created. Any operation that seems to modify them actually creates a new object.</p>"},{"location":"Notes/DataTypes/#immutable-data-types-in-python","title":"Immutable Data Types in Python\u00b6","text":"<ol> <li>Numbers (int, float, complex)</li> <li>String (<code>str</code>)</li> <li>Tuple (<code>tuple</code>)</li> <li>Bytes (<code>bytes</code>)</li> </ol> <p>Note: Attempting to modify an immutable object will result in an error. For example, strings and tuples cannot be changed after creation.</p>"},{"location":"Notes/DataTypes/#mutable-data-types","title":"Mutable Data Types\u00b6","text":"<p>Mutable data types are types whose values can be changed after they are created. Operations that modify these objects do not create a new object, but change the original object itself.</p>"},{"location":"Notes/DataTypes/#mutable-data-types-in-python","title":"Mutable Data Types in Python\u00b6","text":"<ol> <li>Set (<code>set</code>)</li> <li>List (<code>list</code>)</li> <li>Dictionary (<code>dict</code>)</li> </ol> <p>Note: You can modify, add, or remove elements from mutable objects.</p>"},{"location":"Notes/Section%201/Chapter%201/","title":"Literals and Variables","text":"<p>In Python, literals represent fixed values like <code>'Hello, World!'</code> or numbers such as <code>1</code> and <code>2.0</code>. A literal is a direct representation of a constant value in your code. Variables, on the other hand, are used to store these values. You can think of variables as labeled containers that hold data, allowing you to reference and manipulate that data later.</p>"},{"location":"Notes/Section%201/Chapter%201/#defining-variables","title":"Defining Variables","text":"<p>In Python, variables are defined using the assignment operator <code>=</code>. Here\u2019s how you can assign values to variables:</p> <pre><code>&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; print(x)\n1\n\n&gt;&gt;&gt; y = 'a string'\n&gt;&gt;&gt; print(y)\na string\n\n&gt;&gt;&gt; foo_bar = 123.456\n&gt;&gt;&gt; print(foo_bar)\n123.456\n</code></pre>"},{"location":"Notes/Section%201/Chapter%201/#the-assignment-operator","title":"The Assignment Operator <code>=</code>","text":"<p>The <code>=</code> operator is used for two main purposes:</p> <ol> <li>Defining a new variable</li> <li>Updating an existing variable</li> </ol> <p>For example:</p> <pre><code>&gt;&gt;&gt; x = 1       # Define a new variable\n&gt;&gt;&gt; x = x + 1   # Update the existing variable by adding 1 to its value\n&gt;&gt;&gt; print(x)\n2\n</code></pre>"},{"location":"Notes/Section%201/Chapter%201/#right-to-left-evaluation","title":"Right-to-Left Evaluation","text":"<p>The assignment operator evaluates expressions from right to left. This means the expression on the right of <code>=</code> is evaluated first, and the result is assigned to the variable on the left.</p>"},{"location":"Notes/Section%201/Chapter%201/#basic-data-types-and-the-type-function","title":"Basic Data Types and the <code>type()</code> Function","text":"<p>Python offers several basic data types to represent different kinds of data. Some of the most common types include:</p> <ul> <li>Integer (<code>int</code>)</li> <li>Float (<code>float</code>)</li> <li>String (<code>str</code>)</li> <li>Boolean (<code>bool</code>)</li> </ul> <p>You can use the <code>type()</code> function to check the type of any object in Python.</p>"},{"location":"Notes/Section%201/Chapter%201/#integer-int","title":"Integer (<code>int</code>)","text":"<p>Integers are whole numbers, either positive or negative. Here\u2019s an example:</p> <pre><code>&gt;&gt;&gt; print(1)\n1\n\n&gt;&gt;&gt; type(1)\n&lt;class 'int'&gt;\n</code></pre>"},{"location":"Notes/Section%201/Chapter%201/#float-float","title":"Float (<code>float</code>)","text":"<p>Floats are numbers that contain decimal points, representing real numbers. Both <code>1.0</code> and <code>1.</code> are valid float literals in Python:</p> <pre><code>&gt;&gt;&gt; print(1.0)\n1.0\n\n&gt;&gt;&gt; type(1.0)\n&lt;class 'float'&gt;\n\n&gt;&gt;&gt; print(1.)\n1.0\n</code></pre> <p>In Python, <code>1.</code> and <code>1.0</code> are equivalent and represent the same float value.</p>"},{"location":"Notes/Section%201/Chapter%201/#string-str","title":"String (<code>str</code>)","text":"<p>Strings are sequences of characters, enclosed within single quotes <code>' '</code> or double quotes <code>\" \"</code>:</p> <pre><code>&gt;&gt;&gt; print('one')\none\n\n&gt;&gt;&gt; type(\"one\")\n&lt;class 'str'&gt;\n</code></pre>"},{"location":"Notes/Section%201/Chapter%201/#boolean-bool","title":"Boolean (<code>bool</code>)","text":"<p>Booleans represent truth values and can only have two possible outcomes: <code>True</code> or <code>False</code>. Note that in Python, these values are case-sensitive. Lowercase <code>true</code> and <code>false</code> are not recognized as valid boolean values.</p> <pre><code>&gt;&gt;&gt; print(True)\nTrue\n\n&gt;&gt;&gt; type(False)\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"Notes/Section%201/Chapter%201/#comments-in-python","title":"Comments in Python","text":"<p>Comments are lines of code that the Python interpreter ignores. Comments help make your code easier to understand, but they don\u2019t affect how the program runs. In Python, a comment starts with the <code>#</code> symbol.</p>"},{"location":"Notes/Section%201/Chapter%201/#single-line-comments","title":"Single-Line Comments","text":"<pre><code>&gt;&gt;&gt; # This is a comment\n&gt;&gt;&gt; # print(1)\n</code></pre> <p>Since the second line is a comment, the statement <code>print(1)</code> is not executed, and no output is produced.</p>"},{"location":"Notes/Section%201/Chapter%201/#inline-comments","title":"Inline Comments","text":"<p>You can also add comments at the end of a line of code:</p> <pre><code>&gt;&gt;&gt; print(1)  # This line prints the number 1\n1\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/","title":"Operators","text":""},{"location":"Notes/Section%201/Chapter%202/#1-arithmetic-operators","title":"1. Arithmetic Operators","text":"<p>An arithmetic operation in Python involves applying mathematical operators to values (operands). Here's the anatomy of an operation:</p> <pre><code>&gt;&gt;&gt; 10 + 5\n15\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#arithmetic-operator-symbols-and-their-operations","title":"Arithmetic Operator Symbols and Their Operations","text":"Operator Operation + Addition - Subtraction * Multiplication / Division // Floor Division % Modulus (Remainder) ** Exponentiation <p>These operators are binary operators, meaning they operate on two operands. Let's explore each operator:</p> <pre><code>&gt;&gt;&gt; 10 + 5   # Addition\n15\n&gt;&gt;&gt; 10 - 5   # Subtraction\n5\n&gt;&gt;&gt; 10 * 5   # Multiplication\n50\n&gt;&gt;&gt; 10 / 5   # Division\n2.0\n&gt;&gt;&gt; 10 // 5  # Floor Division\n2\n&gt;&gt;&gt; 10 % 5   # Modulus (Remainder)\n0\n&gt;&gt;&gt; 10 ** 5  # Exponentiation (Power)\n100000\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#explanation-of-floor-division-modulus-and-exponentiation","title":"Explanation of Floor Division, Modulus, and Exponentiation","text":"<ul> <li><code>//</code> Floor Division: Divides two numbers and returns the integer quotient, discarding any remainder.</li> </ul> <pre><code>&gt;&gt;&gt; 8 // 3\n2  # The quotient is 2, remainder is discarded.\n</code></pre> <ul> <li><code>%</code> Modulus: Returns the remainder of a division.</li> </ul> <pre><code>&gt;&gt;&gt; 10 % 3\n1  # The remainder is 1.\n</code></pre> <ul> <li>**<code>**</code> Exponentiation**: Raises one number to the power of another.</li> </ul> <pre><code>&gt;&gt;&gt; 2 ** 3\n8  # 2 raised to the power of 3.\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#division-vs-floor-division","title":"Division vs Floor Division","text":"<p>The <code>/</code> operator performs division and returns the exact result (as a float), while <code>//</code> returns only the integer part (quotient).</p> <pre><code>&gt;&gt;&gt; 5 / 2\n2.5  # Standard division\n&gt;&gt;&gt; 5 // 2\n2    # Floor division\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#unary-operators-and-","title":"Unary Operators: <code>+</code> and <code>-</code>","text":"<p>Unlike the binary operators mentioned above, the <code>+</code> and <code>-</code> operators can also act as unary operators (operating on one operand). They indicate positive or negative numbers.</p> <pre><code>&gt;&gt;&gt; -2    # Unary minus\n-2\n&gt;&gt;&gt; +2    # Unary plus\n2\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#variable-usage-in-arithmetic-operations","title":"Variable Usage in Arithmetic Operations","text":"<p>While we've used literals so far, arithmetic operations can also be applied to variables:</p> <pre><code>&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = x * 5\n&gt;&gt;&gt; print(x, y)\n1 5\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#2-relational-operators","title":"2. Relational Operators","text":"<p>Relational operators are used to compare two values. The result is a boolean (<code>True</code> or <code>False</code>).</p>"},{"location":"Notes/Section%201/Chapter%202/#relational-operator-symbols-and-their-operations","title":"Relational Operator Symbols and Their Operations","text":"Operator Operation &gt; Greater than &lt; Less than &gt;= Greater than or equal to &lt;= Less than or equal to == Equal to != Not equal to <p>These operators are also binary operators. Examples:</p> <pre><code>&gt;&gt;&gt; 10 &gt; 5\nTrue\n&gt;&gt;&gt; 10 &lt; 5\nFalse\n&gt;&gt;&gt; 10 &gt;= 5\nTrue\n&gt;&gt;&gt; 10 &lt;= 5\nFalse\n&gt;&gt;&gt; 10 == 5\nFalse\n&gt;&gt;&gt; 10 != 5\nTrue\n</code></pre> <p>Relational operators are also known as comparison operators, as they compare two operands and return a boolean value. You can assign the result of a comparison to a variable:</p> <pre><code>&gt;&gt;&gt; x = 10\n&gt;&gt;&gt; y = 15\n&gt;&gt;&gt; z = y &gt; x\n&gt;&gt;&gt; print(z)\nTrue\n</code></pre> <p>Note: The <code>==</code> operator checks for equality and should not be confused with <code>=</code> which is used for assignment.</p>"},{"location":"Notes/Section%201/Chapter%202/#3-logical-operators","title":"3. Logical Operators","text":"<p>Logical operators are used to combine multiple boolean expressions. They operate on boolean values and return a boolean result.</p>"},{"location":"Notes/Section%201/Chapter%202/#logical-operator-symbols-and-their-operations","title":"Logical Operator Symbols and Their Operations","text":"Operator Operation <code>not</code> Logical negation <code>and</code> Logical conjunction <code>or</code> Logical disjunction <ul> <li><code>and</code> and <code>or</code> are binary operators.</li> <li><code>not</code> is a unary operator.</li> </ul>"},{"location":"Notes/Section%201/Chapter%202/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; True and False\nFalse\n\n&gt;&gt;&gt; True or False\nTrue\n\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; y = not x\n&gt;&gt;&gt; print(y)\nTrue\n</code></pre> <p>The <code>not</code> operator inverts the boolean value (<code>True</code> becomes <code>False</code>, and vice versa). Parentheses can be used but are optional:</p> <pre><code>&gt;&gt;&gt; x = True\n&gt;&gt;&gt; not x\nFalse\n\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; not(x)\nTrue\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#4-code-convention","title":"4. Code Convention","text":"<p>Consider the following lines of code:</p> <pre><code>&gt;&gt;&gt; print(1 + 2)\n3\n&gt;&gt;&gt; print(1+2)\n3\n</code></pre> <p>Both lines produce the same output. In this course, we will follow the first convention\u2014always adding spaces around operators for readability:</p> <pre><code>&gt;&gt;&gt; x = 2  # We will follow this.\n&gt;&gt;&gt; x=2    # We will NOT follow this.\n</code></pre> <p>Both are syntactically correct, but adding spaces makes the code more readable.</p>"},{"location":"Notes/Section%201/Chapter%202/#5-expressions","title":"5. Expressions","text":"<p>An expression in Python is a combination of literals, variables, and operators that evaluates to a value. Here are a few examples:</p> <pre><code>1 + 4 / 4 ** 0\nx / y + z * 2.0\n3 &gt; 4 and 1 &lt; 10\nnot True and False\n</code></pre> <p>Each expression evaluates to a value, which has a specific type. For example:</p> <ul> <li>The first two expressions result in a <code>float</code>.</li> <li>The next two result in a <code>bool</code>.</li> </ul>"},{"location":"Notes/Section%201/Chapter%202/#arithmetic-expressions","title":"Arithmetic Expressions","text":"<p>An arithmetic expression evaluates to a numeric value (<code>int</code> or <code>float</code>). Here's an example:</p> <pre><code>&gt;&gt;&gt; 1 + 2\n3\n&gt;&gt;&gt; type(1 + 2)\n&lt;class 'int'&gt;\n</code></pre> <p>If one operand is a <code>float</code>, the result will also be a <code>float</code>:</p> <pre><code>&gt;&gt;&gt; 1.0 + 2\n3.0\n&gt;&gt;&gt; type(1.0 + 2)\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#boolean-expressions","title":"Boolean Expressions","text":"<p>A boolean expression results in a <code>bool</code> value (<code>True</code> or <code>False</code>), typically through the use of relational or logical operators:</p> <pre><code>&gt;&gt;&gt; 2 &gt; 1\nTrue\n&gt;&gt;&gt; type(2 &gt; 1)\n&lt;class 'bool'&gt;\n</code></pre> <p>Similarly, logical operators produce boolean results:</p> <pre><code>&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; type(True and False)\n&lt;class 'bool'&gt;\n</code></pre>"},{"location":"Notes/Section%201/Chapter%202/#truth-tables-for-logical-operators","title":"Truth Tables for Logical Operators","text":"<p>A truth table lists all possible outcomes for a logical expression. For example, the truth table for <code>or</code> is:</p> X Y X or Y True True True True False True False True True False False False <p>By understanding these operators and how they work in expressions, you'll have a strong foundation to write more complex Python programs.</p>"},{"location":"Notes/Section%201/Chapter%203/","title":"Arithmetic Expressions: Precedence and Order","text":""},{"location":"Notes/Section%201/Chapter%203/#precedence-of-operators","title":"Precedence of Operators","text":"<p>When an expression has multiple operators, Python follows a predefined order of precedence to determine how to evaluate it. For example:</p> <pre><code>&gt;&gt;&gt; 4 // 2 - 1\n1\n</code></pre> <p>In this case, the <code>//</code> operator (floor division) has higher precedence than <code>-</code> (subtraction), so it is evaluated first.</p>"},{"location":"Notes/Section%201/Chapter%203/#precedence-table","title":"Precedence Table","text":"<ol> <li><code>**</code> (Exponentiation)</li> <li><code>*</code>, <code>/</code>, <code>//</code>, <code>%</code> (Multiplication, Division, Floor Division, Modulus)</li> <li><code>+</code>, <code>-</code> (Addition, Subtraction)</li> </ol> <p>Let's take a more complex example:</p> <pre><code>&gt;&gt;&gt; 3 ** 2 * 4 - 4\n32\n</code></pre> <p>Here, the exponentiation (<code>**</code>) is performed first:</p> <pre><code>(3 ** 2) * 4 - 4\n(9) * 4 - 4\n36 - 4\n32\n</code></pre>"},{"location":"Notes/Section%201/Chapter%203/#order-of-evaluation-left-to-right","title":"Order of Evaluation (Left-to-Right)","text":"<p>Most operators are evaluated from left to right, except for the exponentiation (<code>**</code>) and assignment (<code>=</code>) operators, which are evaluated from right to left.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; 3 - 2 + 1\n2\n</code></pre> <p>This evaluates as:</p> <pre><code>(3 - 2) + 1 = 1 + 1 = 2\n</code></pre> <p>Another example with modulus (<code>%</code>):</p> <pre><code>&gt;&gt;&gt; 8 % 4 % 2\n0\n</code></pre> <p>Evaluated as:</p> <pre><code>(8 % 4) % 2 = 0 % 2 = 0\n</code></pre> <p>However, exponentiation works differently:</p> <pre><code>&gt;&gt;&gt; 2 ** 3 ** 0\n2\n</code></pre> <p>This is evaluated from right to left:</p> <pre><code>2 ** (3 ** 0) = 2 ** 1 = 2\n</code></pre>"},{"location":"Notes/Section%201/Chapter%203/#boolean-expressions-precedence-and-order","title":"Boolean Expressions: Precedence and Order","text":""},{"location":"Notes/Section%201/Chapter%203/#basic-boolean-expressions","title":"Basic Boolean Expressions","text":"<p>A simple boolean expression evaluates to <code>True</code> or <code>False</code>:</p> <pre><code>&gt;&gt;&gt; 1 &gt; 0\nTrue\n</code></pre> <p>You can combine multiple conditions using logical operators like <code>and</code> and <code>or</code>:</p> <pre><code>&gt;&gt;&gt; 3 &lt; 3.14 &lt; 4\nTrue\n</code></pre>"},{"location":"Notes/Section%201/Chapter%203/#precedence-and-order-of-logical-operators","title":"Precedence and Order of Logical Operators","text":"<p>Similar to arithmetic operators, logical operators follow precedence rules:</p> <ol> <li><code>not</code> (negation)</li> <li><code>and</code> (conjunction)</li> <li><code>or</code> (disjunction)</li> </ol> <p>Logical expressions are evaluated from left to right, but operator precedence affects the order.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; not True and False\nFalse\n</code></pre> <p>The precedence of <code>not</code> is higher than <code>and</code>, so it's evaluated as:</p> <pre><code>(not True) and False = False and False = False\n</code></pre> <p>Another example:</p> <pre><code>&gt;&gt;&gt; True or False and False\nTrue\n</code></pre> <p>Here, <code>and</code> has higher precedence than <code>or</code>, so it's evaluated as:</p> <pre><code>True or (False and False) = True or False = True\n</code></pre>"},{"location":"Notes/Section%201/Chapter%203/#beware-of-float-comparisons","title":"Beware of Float Comparisons","text":"<p>Be cautious when comparing floats, as Python uses approximations to represent floating-point numbers. For example:</p> <pre><code>&gt;&gt;&gt; 10.00000000000000000000001 &gt; 10\nFalse\n</code></pre> <p>This is because the float precision rounds the number to <code>10.0</code>.</p> <pre><code>&gt;&gt;&gt; 0.1 * 3 == 0.3\nFalse\n&gt;&gt;&gt; 0.1 * 3\n0.30000000000000004\n</code></pre>"},{"location":"Notes/Section%201/Chapter%203/#short-circuit-evaluation","title":"Short Circuit Evaluation","text":"<p>Python uses short circuit evaluation to optimize boolean expressions. If the outcome of a logical operation can be determined by the first operand, the second operand is not evaluated.</p> <p>For example:</p> <pre><code>&gt;&gt;&gt; True or (1 / 0)\nTrue\n</code></pre> <p>No error occurs because Python doesn't evaluate <code>(1 / 0)</code> once it determines that the expression is <code>True</code>.</p> <p>This behavior applies to <code>and</code> as well. If the first operand is <code>False</code>, the second operand isn't evaluated:</p> <pre><code>&gt;&gt;&gt; False and (1 / 0)\nFalse\n</code></pre> <p>This makes short circuit evaluation useful in avoiding errors in complex expressions.</p>"},{"location":"Notes/Section%201/Chapter%204/","title":"Strings in Python","text":""},{"location":"Notes/Section%201/Chapter%204/#quotes-single-double-and-triple","title":"Quotes: Single, Double, and Triple","text":"<p>A string in Python can be enclosed in single (<code>'</code>), double (<code>\"</code>), or triple quotes (<code>'''</code> or <code>\"\"\"</code>). Triple quotes are typically used for multi-line strings.</p> <p>Example:</p> <pre><code>x = '''first line\nsecond line\nthird line'''\nprint(x)\n</code></pre> <p>Output:</p> <pre><code>first line\nsecond line\nthird line\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#length-of-strings","title":"Length of Strings","text":"<p>Use the <code>len()</code> function to determine the length of a string.</p> <p>Example:</p> <pre><code>x = 'good'\nprint(len(x))  # Output: 4\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#operations-on-strings","title":"Operations on Strings","text":"<ol> <li>Concatenation: Using the <code>+</code> operator.</li> </ol> <pre><code>string1 = 'first'\nstring2 = ','\nstring3 = 'second'\nresult = string1 + string2 + string3\nprint(result)  # Output: first,second\n</code></pre> <ol> <li>Replication: Using the <code>*</code> operator to repeat a string.</li> </ol> <pre><code>s = 'good'\nprint(s * 5)  # Output: goodgoodgoodgoodgood\n</code></pre> <ol> <li>Comparison: Using <code>==</code>, <code>&gt;</code>, <code>&lt;</code> operators for lexicographic comparisons.</li> </ol> <pre><code>print('good' &gt; 'bad')  # Output: True\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#escape-characters","title":"Escape Characters","text":"<p>The backslash (<code>\\</code>) is used to introduce special characters.</p> <ul> <li><code>\\n</code> for newline</li> <li><code>\\t</code> for tab</li> <li><code>\\'</code> for escaping single quotes</li> </ul> <p>Example:</p> <pre><code>print('This is the first line.\\nThis is the second line.')\n</code></pre> <p>Output:</p> <pre><code>This is the first line.\nThis is the second line.\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#substrings","title":"Substrings","text":"<p>The <code>in</code> keyword checks if a string is a substring of another.</p> <p>Example:</p> <pre><code>a = 'good'\nb = 'very good'\nprint(a in b)  # Output: True\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#indexing-and-slicing","title":"Indexing and Slicing","text":"<p>Strings support both positive and negative indexing. The first character has index <code>0</code>, and the last has index <code>-1</code>.</p> <p>Example:</p> <pre><code>word = 'world'\nprint(word[0])   # Output: w\nprint(word[-1])  # Output: d\n</code></pre> <p>Slicing: To extract a portion of a string.</p> <pre><code>email = 'CS_10_014@iitm.ac.in'\nroll = email[6:9]  # Output: 014\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#immutability-of-strings","title":"Immutability of Strings","text":"<p>Strings are immutable in Python, meaning their contents cannot be changed once created.</p> <p>Example:</p> <pre><code>word = 'hello'\nword[0] = 'H'  # This will raise an error\n</code></pre>"},{"location":"Notes/Section%201/Chapter%204/#string-methods","title":"String Methods","text":"<ul> <li><code>capitalize()</code>: Capitalizes the first letter.</li> <li><code>isalpha()</code>: Checks if all characters are alphabetic.</li> </ul> <p>Example:</p> <pre><code>sentence = 'hello world'\nprint(sentence.capitalize())  # Output: Hello world\n\nname = 'John'\nprint(name.isalpha())  # Output: True\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/","title":"Variables","text":""},{"location":"Notes/Section%202/Chapter%201/#introduction","title":"Introduction","text":"<p>Variables are containers used to store values. In Python, variables are defined using the assignment operator <code>=</code>. For example:</p> <pre><code>x = 1\ny = 100.0\nz = \"good\"\n</code></pre> <p>Variables can also be updated using the assignment operator:</p> <pre><code>x = 1\nprint('The initial value of x is', x)\nx = 2\nprint('The value after updating x is', x)\n</code></pre> <p>The output is:</p> <pre><code>The initial value of x is 1\nThe value after updating x is 2\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#assignment-operator","title":"Assignment Operator","text":"<p>The syntax of the assignment statement is:</p> <pre><code>&lt;variable-name&gt; = &lt;expression&gt;\n</code></pre> <p>The assignment operator works from right to left. For example:</p> <pre><code>x = 1 + 2 * 3 / 2\nprint(x)\n</code></pre> <p>The output is:</p> <pre><code>4.0\n</code></pre> <p>Having a literal to the left of the assignment operator will result in an error:</p> <pre><code>3 = x\n</code></pre> <p>This will throw the following error:</p> <pre><code>SyntaxError: cannot assign to literal\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#dynamic-typing","title":"Dynamic Typing","text":"<p>Python supports dynamic typing. In a dynamically typed language, a variable is simply a value bound to a name; the value has a type \u2014 like <code>int</code> or <code>str</code> \u2014 but the variable itself doesn\u2019t. For example:</p> <pre><code>a = 1\nprint(type(a))\na = 1 / 2\nprint(type(a))\n</code></pre> <p>The output is:</p> <pre><code>&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#referencing-vs-defining","title":"Referencing vs Defining","text":"<p>When a variable that has already been defined is used in an expression, we say that the variable is being referenced.</p> <pre><code>x = 2\nprint(x * x, 'is the square of', x)\n</code></pre> <p>If a variable is referenced before it has been assigned a value, Python throws a <code>NameError</code>:</p> <pre><code>print(someVar)\n</code></pre> <p>The output is:</p> <pre><code>NameError: name 'someVar' is not defined\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#keywords-and-naming-rules","title":"Keywords and Naming Rules","text":"<p>Certain words in Python, called keywords, have special meanings. Examples include:</p> <pre><code>not, and, or, if, for, while, in, is, def, class\n</code></pre> <p>Keywords cannot be used as variable names:</p> <pre><code>and = 2\n</code></pre> <p>In addition to this restriction, variable names in Python must follow these rules:</p> <ol> <li>A variable name can only contain alphanumeric characters and underscores: <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>_</code></li> <li>A variable name must start with a letter or an underscore.</li> <li>Variable names are case-sensitive (<code>age</code>, <code>Age</code>, and <code>AGE</code> are three different variables).</li> </ol>"},{"location":"Notes/Section%202/Chapter%201/#reusing-variables","title":"Reusing Variables","text":"<p>Variables can be used in computing the values of other variables. For example:</p> <pre><code>x = 10\ny = x ** 2\nz = (x + 1) * (y + 1)\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#multiple-assignment","title":"Multiple Assignment","text":"<p>You can assign values to multiple variables in one line:</p> <pre><code>x, y = 1, 2\n</code></pre> <p>Another way is to assign the same value to multiple variables:</p> <pre><code>x = y = z = 10\n</code></pre> <p>Even though <code>x</code>, <code>y</code>, and <code>z</code> start off equal, the equality is broken if one of them is updated:</p> <pre><code>x = x * 1\ny = y * 2\nz = z * 3\nprint(x, y, z)\n</code></pre> <p>The output is:</p> <pre><code>10 20 30\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#assignment-shortcuts","title":"Assignment Shortcuts","text":"<p>Python provides shorthand notations for arithmetic operations combined with assignment:</p> Shortcut Meaning <code>x += a</code> <code>x = x + a</code> <code>x -= a</code> <code>x = x - a</code> <code>x *= a</code> <code>x = x * a</code> <code>x /= a</code> <code>x = x / a</code> <code>x %= a</code> <code>x = x % a</code> <code>x **= a</code> <code>x = x ** a</code> <p>For example:</p> <pre><code>x = 1\nx += 1\nprint(x)\n</code></pre> <p>The output is:</p> <pre><code>2\n</code></pre>"},{"location":"Notes/Section%202/Chapter%201/#deleting-variables","title":"Deleting Variables","text":"<p>You can delete variables using the <code>del</code> keyword:</p> <pre><code>x = 100\nprint('x is a variable whose value is', x)\nprint('we are now going to delete x')\ndel x\nprint(x)\n</code></pre> <p>After the deletion, trying to access <code>x</code> will throw a <code>NameError</code>:</p> <pre><code>NameError: name 'x' is not defined\n</code></pre>"},{"location":"Notes/Section%202/Chapter%202/","title":"Input","text":""},{"location":"Notes/Section%202/Chapter%202/#accepting-input-from-the-user","title":"Accepting Input from the User","text":"<p>Accepting input from the user is a common operation in programming. Any piece of software needs a functional interface to interact with the user. For example, on apps like Facebook, Instagram, and Twitter, the text entered in comment boxes is considered input. This input is processed by code in the backend and displayed as a comment.</p> <p>Python provides a built-in function <code>input()</code> to accept input from the user. It\u2019s simple yet powerful:</p> <pre><code>x = input()\nprint('The input entered by the user is', x)\n</code></pre> <p>In this case, the interpreter waits for you to enter text. Once you press enter, the input is stored in the variable <code>x</code>. The output looks like this:</p> <pre><code>1\nThe input entered by the user is 1\n</code></pre> <p>You can also prompt the user to enter a specific type of input by passing a string argument to the <code>input()</code> function:</p> <pre><code>x = input('Enter an integer between 0 and 10: ')\nprint('The number entered by the user is', x)\n</code></pre> <p>Now, let\u2019s examine the type of the variable <code>x</code>:</p> <pre><code>x = input()\nprint('The input entered by the user is of type', type(x))\n</code></pre> <p>No matter what you enter (integer, float, string, or boolean), the <code>input()</code> function always returns a string. If the user enters <code>123</code>, it's processed as the string <code>'123'</code>.</p>"},{"location":"Notes/Section%202/Chapter%202/#type-conversion","title":"Type Conversion","text":"<p>If you want to convert a string into an integer, Python provides the built-in function <code>int()</code>:</p> <pre><code>x = '123'\nprint('The type of x is', type(x))\ny = int(x)\nprint('The type of y is', type(y))\n</code></pre> <p>This process is called type conversion. You can also convert an integer to a string using the <code>str()</code> function:</p> <pre><code>x = 123\nprint('The type of x is', type(x))\ny = str(x)\nprint('The type of y is', type(y))\n</code></pre> <p>To accept an integer input from the user, you can convert the string returned by <code>input()</code> into an integer:</p> <pre><code>x = int(input('Enter an integer: '))\nprint('The integer entered by the user is', x)\n</code></pre> <p>You can also combine the two operations in one line:</p> <pre><code>x = int(input())\nprint('The integer entered by the user is', x)\n</code></pre> <p>In this case, the output of the <code>input()</code> function is passed as an argument to <code>int()</code>. Be careful, though! If the user enters a float value, the following code will raise a <code>ValueError</code>:</p> <pre><code>x = int(input())    # user enters a float value here\n</code></pre>"},{"location":"Notes/Section%202/Chapter%202/#built-in-functions","title":"Built-in Functions","text":"<p>We\u2019ve been using the term built-in functions often. These are predefined functions in Python that accept inputs and produce outputs. For example, <code>print()</code> is a built-in function that accepts input and prints it to the console. Here are a few more useful built-in functions:</p> <ul> <li><code>round()</code>: Accepts a number and returns the closest integer. Example: <code>round(1.2)</code> returns <code>1</code>, while <code>round(1.9)</code> returns <code>2</code>.</li> <li><code>abs()</code>: Accepts a number and returns its absolute value. Example: <code>abs(-1.2)</code> returns <code>1.2</code>.</li> <li><code>int()</code>: Converts a string representing an integer into an <code>int</code>. Example: <code>int('123')</code> returns <code>123</code>. If a float is passed, the decimal part is discarded. Example: <code>int(1.2)</code> returns <code>1</code>, and <code>int(-2.5)</code> returns <code>-2</code>.</li> <li><code>pow()</code>: Accepts two arguments and returns the value of <code>x ** y</code>. Example: <code>pow(2, 3)</code> returns <code>8</code>. It also supports a third argument: <code>pow(x, y, z)</code> returns <code>(x ** y) % z</code>.</li> <li><code>isinstance()</code>: Used to check if an object is of a specific type. Example: <code>isinstance(3, int)</code> returns <code>True</code>, and <code>isinstance('hello', str)</code> also returns <code>True</code>.</li> </ul> <p>The Python documentation provides a complete list of built-in functions for more reference.</p>"},{"location":"Notes/Section%202/Chapter%203/","title":"Conditional Statements","text":""},{"location":"Notes/Section%202/Chapter%203/#if-statement","title":"if Statement","text":"<p>Let's explore the idea of conditional statements by solving a simple problem:</p>"},{"location":"Notes/Section%202/Chapter%203/#problem","title":"Problem","text":"<p>Accept an integer as input from the user. If the number is greater than or equal to zero, print: non-negative.</p>"},{"location":"Notes/Section%202/Chapter%203/#solution","title":"Solution","text":"<pre><code>x = int(input())\nif x &gt;= 0:\n    print('non-negative')\n</code></pre> <p>The <code>if</code> is a keyword in Python. The expression next to <code>if</code> is a boolean expression, also called the if-condition or just the condition. The body of the if statement is indented, indicating which lines are to be executed if the condition evaluates to True.</p> <p>The following diagram captures the control flow of the <code>if</code> statement:</p> <p></p>"},{"location":"Notes/Section%202/Chapter%203/#code-snippet","title":"Code Snippet","text":"<pre><code>x = int(input())\nif x &gt;= 0:\n    print('non-negative')\n</code></pre> <p>Note that line-3 in the solution code is indented. In this case, the indentation corresponds to four spaces, and it's crucial to keep this consistent throughout the program.</p>"},{"location":"Notes/Section%202/Chapter%203/#example","title":"Example","text":"<p>To understand how indentation works, consider the following code blocks:</p>"},{"location":"Notes/Section%202/Chapter%203/#left","title":"Left","text":"<pre><code>x = 1\nif x &gt;= 0:\n    print('non-negative')\n    print('inside if')\nprint('outside if')\n</code></pre>"},{"location":"Notes/Section%202/Chapter%203/#right","title":"Right","text":"<pre><code>x = -1\nif x &gt;= 0:\n    print('non-negative')\n    print('inside if')\nprint('outside if')\n</code></pre> <p>Output:</p> <ul> <li>Left:</li> </ul> <pre><code>non-negative\ninside if\noutside if\n</code></pre> <ul> <li>Right:   <pre><code>outside if\n</code></pre></li> </ul> <p>Lines 3-5 in the left code make up the if-block. Whenever the if-condition evaluates to True, the interpreter executes the body of the if.</p>"},{"location":"Notes/Section%202/Chapter%203/#if-else-statement","title":"if-else Statement","text":"<p>Let's add another level of complexity to the problem.</p>"},{"location":"Notes/Section%202/Chapter%203/#problem_1","title":"Problem","text":"<p>Accept an integer as input from the user. If the number is greater than or equal to zero, print: non-negative. If the number is less than zero, print negative.</p>"},{"location":"Notes/Section%202/Chapter%203/#solution_1","title":"Solution","text":"<pre><code>x = int(input())\nif x &gt;= 0:\n    print('non-negative')\nelse:\n    print('negative')\n</code></pre> <p><code>else</code> is another keyword in Python. When the <code>if</code> condition is True, the statements inside the if block are executed. When the condition is False, the statements inside the else block are executed.</p>"},{"location":"Notes/Section%202/Chapter%203/#points-to-remember","title":"Points to Remember","text":"<ul> <li><code>if</code> and <code>else</code> must be at the same level of indentation.</li> <li><code>else</code> cannot exist independently of an <code>if</code> statement.</li> <li><code>else</code> cannot have a condition associated with it.</li> </ul>"},{"location":"Notes/Section%202/Chapter%203/#if-elif-else-statement","title":"if-elif-else Statement","text":"<p>Time for another bump in complexity.</p>"},{"location":"Notes/Section%202/Chapter%203/#problem_2","title":"Problem","text":"<p>Accept an integer as input from the user. If the number is greater than zero, print: positive. If the number is less than zero, print negative. If the number is equal to zero, print zero.</p>"},{"location":"Notes/Section%202/Chapter%203/#solution_2","title":"Solution","text":"<pre><code>x = int(input())\nif x &gt; 0:\n    print('positive')\nelif x == 0:\n    print('zero')\nelse:\n    print('negative')\n</code></pre> <p><code>elif</code> is a shorthand for else-if.</p>"},{"location":"Notes/Section%202/Chapter%203/#example-inputs-and-outputs","title":"Example Inputs and Outputs","text":"Input Output x = 1 positive x = 0 zero x = -1 negative <p>The general syntax for <code>if-elif-else</code> is:</p> <pre><code>if &lt;condition-1&gt;:\n    &lt;statement-1&gt;\nelif &lt;condition-2&gt;:\n    &lt;statement-2&gt;\nelse:\n    &lt;statement-3&gt;\n</code></pre> <p>Features to Note:</p> <ul> <li>Exactly one of the three statements gets executed.</li> <li>If an <code>if</code> or <code>elif</code> condition evaluates to True, the body of that block is executed, and the flow exits the entire if-elif-else block.</li> <li>There can be multiple <code>elif</code> conditions after the <code>if</code>.</li> </ul>"},{"location":"Notes/Section%202/Chapter%203/#nested-conditional-statements","title":"Nested Conditional Statements","text":"<p>Consider the following problem:</p>"},{"location":"Notes/Section%202/Chapter%203/#problem_3","title":"Problem","text":"<p>Accept three distinct integers as input from the user. If the numbers have been entered in ascending order, print in ascending order. If not, print not in ascending order.</p>"},{"location":"Notes/Section%202/Chapter%203/#incomplete-solution","title":"Incomplete Solution","text":"<pre><code>x = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    print('in ascending order')\nelse:\n    print('not in ascending order')\n</code></pre> <p>The issue with this solution is that it doesn't check if <code>y &lt; z</code>. The complete solution is given below:</p>"},{"location":"Notes/Section%202/Chapter%203/#complete-solution","title":"Complete Solution","text":"<pre><code>x = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    if y &lt; z:\n        print('in ascending order')\n    else:\n        print('not in ascending order')\nelse:\n    print('not in ascending order')\n</code></pre>"},{"location":"Notes/Section%202/Chapter%203/#indentation","title":"Indentation","text":"<p>Whenever a new if block is introduced, its body should have exactly one level of indentation with respect to its if-condition.</p>"},{"location":"Notes/Section%202/Chapter%203/#defining-variables-inside-if","title":"Defining Variables Inside if","text":"<p>Consider the following snippet of code:</p> <pre><code>x = int(input())\nif x % 5 == 0:\n    output = 'the number is divisible by 5'\nprint(output)\n</code></pre>"},{"location":"Notes/Section%202/Chapter%203/#observation","title":"Observation","text":"<p>Run the code multiple times, varying the input each time. When the input is a multiple of 5, the code runs without any error. However, when the input is not divisible by 5, the code throws a <code>NameError</code> because the variable <code>output</code> is referenced even when it has not been defined.</p>"},{"location":"Notes/Section%202/Chapter%204/","title":"Library in Python","text":"<p>A library is a collection of functions that share a common theme. This loose definition will become clear when we start working with a library.</p>"},{"location":"Notes/Section%202/Chapter%204/#using-the-calendar-library","title":"Using the <code>calendar</code> Library","text":"<p>Consider the following problem:</p>"},{"location":"Notes/Section%202/Chapter%204/#problem","title":"Problem","text":"<p>In the year 3000, which day of the week will August 15th fall on?</p>"},{"location":"Notes/Section%202/Chapter%204/#solution","title":"Solution","text":"<pre><code>import calendar\ncalendar.prmonth(3000, 8)\n</code></pre>"},{"location":"Notes/Section%202/Chapter%204/#output","title":"Output","text":"<p>When the above code is executed, the output is:</p> <pre><code>    August 3000\nMo Tu We Th Fr Sa Su\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n</code></pre> <p>15th of August falls on a Friday. Isn't that lovely? It took just two lines of code!</p> <p>The <code>calendar</code> library is one among several libraries in Python's standard library. A comprehensive list can be found here.</p> <p>In the code, <code>calendar</code> is the name of the library and <code>import</code> is the keyword used to include this library as part of the code. The <code>calendar</code> library is a collection of functions that are related to calendars. The <code>prmonth</code> function accepts <code>&lt;year&gt;</code> and <code>&lt;month&gt;</code> as input and displays the calendar for that month in the specified year.</p>"},{"location":"Notes/Section%202/Chapter%204/#note","title":"Note","text":"<p>If we skip the import step:</p> <pre><code># import calendar\ncalendar.prmonth(3000, 8)\n</code></pre> <p>It gives the following error:</p> <pre><code>NameError: name 'calendar' is not defined\n</code></pre> <p>To access a function defined inside a library, we use the following syntax:</p> <pre><code>&lt;library&gt;.&lt;function&gt;(&lt;arguments&gt;)\n</code></pre>"},{"location":"Notes/Section%202/Chapter%204/#alternative-solution","title":"Alternative Solution","text":"<p>Another way to solve the problem is to use the <code>weekday</code> function:</p> <pre><code>import calendar\nprint(calendar.weekday(3000, 8, 15))\n</code></pre>"},{"location":"Notes/Section%202/Chapter%204/#output_1","title":"Output","text":"<p>The output of the above code is <code>4</code>, which means: | Day | Number | |-----------|--------| | Monday | 0 | | Tuesday | 1 | | Wednesday | 2 | | Thursday | 3 | | Friday | 4 | | Saturday | 5 | | Sunday | 6 |</p>"},{"location":"Notes/Section%202/Chapter%204/#using-the-time-library","title":"Using the <code>time</code> Library","text":"<p>Let us now try to answer this hypothetical question:</p>"},{"location":"Notes/Section%202/Chapter%204/#problem_1","title":"Problem","text":"<p>You are stranded on an island in the middle of the Indian Ocean. The island has a computing device that has just one application installed in it: a Python interpreter. You wish to know the current date and time.</p>"},{"location":"Notes/Section%202/Chapter%204/#solution_1","title":"Solution","text":"<pre><code>from time import ctime\nprint('The current time is:', ctime())\n</code></pre>"},{"location":"Notes/Section%202/Chapter%204/#output_2","title":"Output","text":"<pre><code>The current time is: Fri Apr  2 12:24:43 2021\n</code></pre> <p>The syntax of the import statement in line-1 looks different. The <code>from</code> keyword allows us to import a specific function from a library.</p> <p>This way of importing functions is useful when we need just one or two functions from a given library:</p> <pre><code>from time import ctime, sleep\nprint('Current time is:', ctime())\nprint('I am going to sleep for 10 seconds')\nsleep(10)\nprint('Current time is:', ctime())\n</code></pre> <p>The <code>sleep(x)</code> function in the <code>time</code> library suspends the execution of the program for <code>x</code> seconds. If we would be using several functions in the library, it is better to import the entire library.</p>"},{"location":"Notes/Section%202/Chapter%204/#the-zen-of-python","title":"The Zen of Python","text":"<p>As a fun exercise, consider the following code:</p> <pre><code>import this\n</code></pre>"},{"location":"Notes/Section%202/Chapter%204/#output_3","title":"Output","text":"<p>This gives the following output:</p> <pre><code>The Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n</code></pre> <p>These are some nuggets of wisdom from Tim Peters, a \"major contributor to the Python programming language\". Some points make immediate sense, such as \"readability counts\".</p>"},{"location":"Notes/Section%203/Chapter%201/","title":"Loops in Python","text":""},{"location":"Notes/Section%203/Chapter%201/#introduction","title":"Introduction","text":"<p>Consider the following problem:</p>"},{"location":"Notes/Section%203/Chapter%201/#problem","title":"Problem","text":"<p>Print the sum of the first five positive integers.</p>"},{"location":"Notes/Section%203/Chapter%201/#solution","title":"Solution","text":"<pre><code>print(1 + 2 + 3 + 4 + 5)\n</code></pre> <p>Now, how about the following problem?</p>"},{"location":"Notes/Section%203/Chapter%201/#problem_1","title":"Problem","text":"<p>Print the sum of the first 1,000,000 positive integers.</p> <p>The earlier approach is not going to work. If it takes about five seconds on average to write a number followed by the <code>+</code> symbol, how much time will it take to find the sum of all 1 million numbers? Let us check:</p>"},{"location":"Notes/Section%203/Chapter%201/#code","title":"Code","text":"<pre><code>num = 1_000_000     # _ in a number is used when we have large numbers; improves readability\navg_time = 5\nseconds = num * avg_time\nminutes = seconds / 60\nhours = minutes / 60\ndays = hours / 24\nprint('Approximate number of days =', round(days))\n</code></pre> <p>It will take nearly 58 days to sum all 1 million integers! This is assuming that we work like machines that don't need food or sleep. All of this just to do something as trivial as finding the sum of numbers. This is where loops come in.</p>"},{"location":"Notes/Section%203/Chapter%201/#while-loops","title":"<code>while</code> Loops","text":"<p>The \"loopy\" solution to this problem:</p>"},{"location":"Notes/Section%203/Chapter%201/#code_1","title":"Code","text":"<pre><code>total = 0\nnum = 0\nwhile num &lt; 1_000_000:\n    num = num + 1\n    total = total + num\nprint(total)\n</code></pre> <p>The <code>while</code> keyword is used in Python to create a loop. The expression adjacent to <code>while</code> is a boolean expression, called the while-condition. Lines 4 and 5 make up the body of the <code>while</code> loop. If the condition evaluates to <code>True</code>, control enters the body of the <code>while</code>. The lines in the body are sequentially executed. After the last line in the body is executed, the control loops back to the condition evaluation. As long as the condition is <code>True</code>, the body of the <code>while</code> keeps getting executed. The moment the condition becomes <code>False</code>, the body of the <code>while</code> is skipped, and control transfers to the next line. The body of the <code>while</code> loop must always be indented; this helps to separate it from the rest of the code.</p>"},{"location":"Notes/Section%203/Chapter%201/#visual-representation","title":"Visual Representation","text":"<p>Let us consider another example:</p>"},{"location":"Notes/Section%203/Chapter%201/#problem_2","title":"Problem","text":"<p>Keep accepting integers as input from the user until the user enters a negative number. Print the sum of the positive numbers entered by the user. Print <code>0</code> if the user doesn't enter any positive integer.</p>"},{"location":"Notes/Section%203/Chapter%201/#code_2","title":"Code","text":"<pre><code>total = 0\nnum = int(input())\nwhile num &gt;= 0:\n    total += num\n    num = int(input())\nprint(total)\n</code></pre>"},{"location":"Notes/Section%203/Chapter%201/#another-example","title":"Another Example","text":""},{"location":"Notes/Section%203/Chapter%201/#problem_3","title":"Problem","text":"<p>Keep accepting integers as input from the user until the user enters a negative number. Print the maximum among the positive numbers entered by the user. Print <code>0</code> if the user doesn't enter any positive integer.</p>"},{"location":"Notes/Section%203/Chapter%201/#solution_1","title":"Solution","text":"<pre><code># Initialize\nnum = int(input())\nmax_num = 0\n# Loop\nwhile num &gt;= 0:\n    if num &gt; max_num:\n        max_num = num\n    num = int(input())\n# Print output\nprint(max_num)\n</code></pre> <p>Note that lines 6-8 make up the body of the <code>while</code> loop and are indented. Lines 1, 4, and 9 have comments to help the reader understand what is happening in the code.</p>"},{"location":"Notes/Section%203/Chapter%201/#break-and-continue","title":"<code>break</code> and <code>continue</code>","text":"<p>The <code>break</code> and <code>continue</code> keywords are associated with loops in Python.</p>"},{"location":"Notes/Section%203/Chapter%201/#break","title":"<code>break</code>","text":"<p>The <code>break</code> statement is used to exit out of a loop without executing any code that comes below it. For example:</p>"},{"location":"Notes/Section%203/Chapter%201/#code_3","title":"Code","text":"<pre><code>num = 1\nwhile True:\n    if (num % 2 == 0) and (num % 3 == 0) and (num % 4 == 0):\n        break\n    num = num + 1\nprint(num)\n</code></pre> <p>The above code prints the smallest positive integer that is divisible by <code>2</code>, <code>3</code>, and <code>4</code>, which is the same as the LCM of <code>(2, 3, 4)</code>. The moment this number is found, the code breaks out of the loop.</p>"},{"location":"Notes/Section%203/Chapter%201/#continue","title":"<code>continue</code>","text":"<p>The <code>continue</code> statement is used to move to the next iteration of the loop, skipping whatever code comes below it. For example:</p>"},{"location":"Notes/Section%203/Chapter%201/#code_4","title":"Code","text":"<pre><code>x = 0\nwhile x &lt; 50:\n    x = x + 1\n    if x % 3 != 0:\n        continue\n    print(x)\n</code></pre> <p>The code given above prints all positive integers less than or equal to <code>50</code> that are divisible by <code>3</code>. Whenever <code>x</code> is not divisible by <code>3</code>, we do not want to print the number, so we continue to the next iteration.</p>"},{"location":"Notes/Section%203/Chapter%202/","title":"Loops in Python","text":""},{"location":"Notes/Section%203/Chapter%202/#for-loop","title":"<code>for</code> Loop","text":"<p>Let us look at a simple problem of printing numbers. We would like to print the first 5 non-negative integers using a <code>for</code> loop:</p>"},{"location":"Notes/Section%203/Chapter%202/#code","title":"Code","text":"<pre><code>for i in range(5):\n    print(i)\n# A dummy line\n</code></pre>"},{"location":"Notes/Section%203/Chapter%202/#output","title":"Output","text":"<pre><code>0\n1\n2\n3\n4\n</code></pre> <p>In this example:</p> <ul> <li><code>for</code> and <code>in</code> are keywords in Python.</li> <li><code>range</code> is an object that represents a sequence of numbers.</li> <li>Line 2 is the body of the loop.</li> </ul>"},{"location":"Notes/Section%203/Chapter%202/#understanding-the-code","title":"Understanding the Code","text":"<ul> <li>In each iteration of the loop, an element in the sequence is picked up and printed to the console.</li> <li>The sequence is processed from left to right.</li> <li>Once the rightmost element has been printed, control returns to line 1 for one last time. Since there are no more elements to read in the sequence, the control exits the loop.</li> </ul>"},{"location":"Notes/Section%203/Chapter%202/#visual-representation","title":"Visual Representation","text":"<p>Similar to <code>while</code> loops and <code>if-else</code> blocks, the body of a <code>for</code> loop should be indented.</p>"},{"location":"Notes/Section%203/Chapter%202/#range","title":"<code>range()</code>","text":"<p>The <code>range(5)</code> function represents the following sequence: <code>0, 1, 2, 3, 4</code>. In general, <code>range(n)</code> represents the sequence: <code>0, 1, ..., n - 1</code>.</p> <p>The <code>range</code> function is quite versatile. For example, the following code prints all two-digit numbers greater than zero:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_1","title":"Code","text":"<pre><code>for i in range(10, 100):\n    print(i)\n</code></pre> <p><code>range(10, 100)</code> represents the sequence <code>10, 11, ..., 99</code>. In general, <code>range(start, stop)</code> represents the sequence <code>start, start + 1, ..., stop - 1</code>.</p>"},{"location":"Notes/Section%203/Chapter%202/#example-even-two-digit-numbers","title":"Example: Even Two-Digit Numbers","text":"<p>Let us add another level of complexity. The following code prints all even two-digit numbers greater than zero:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_2","title":"Code","text":"<pre><code>for i in range(10, 100, 2):\n    print(i)\n</code></pre> <p><code>range(10, 100, 2)</code> represents the sequence <code>10, 12, ..., 98</code>. In general, <code>range(start, stop, step)</code> represents the sequence <code>start, start + step, start + 2 * step, ..., last</code>, where <code>last</code> is the largest element in this sequence that is less than <code>stop</code>. This is true when the step parameter is positive.</p>"},{"location":"Notes/Section%203/Chapter%202/#equivalents","title":"Equivalents","text":"<p>The following are equivalent:</p> <ul> <li><code>range(n)</code></li> <li><code>range(0, n)</code></li> <li><code>range(0, n, 1)</code></li> </ul>"},{"location":"Notes/Section%203/Chapter%202/#decreasing-sequences","title":"Decreasing Sequences","text":"<p>So far, we have seen only increasing sequences. With the help of a negative step size, we can also come up with decreasing sequences. The following code prints all two-digit even numbers greater than zero in descending order:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_3","title":"Code","text":"<pre><code>for i in range(98, 9, -2):\n    print(i)\n</code></pre> <p>For a negative step value, <code>range(start, stop, step)</code> represents the sequence <code>start, start + step, start + 2 * step, ..., last</code>, where <code>last</code> is the smallest element in the sequence greater than <code>stop</code>.</p>"},{"location":"Notes/Section%203/Chapter%202/#empty-sequences","title":"Empty Sequences","text":"<p>Now, consider the following code:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_4","title":"Code","text":"<pre><code>for i in range(5, 5):\n    print(i)\n</code></pre> <p><code>range(5, 5)</code> is an empty sequence, so the above code will not print anything.</p> <p>Another instance of an empty sequence:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_5","title":"Code","text":"<pre><code>for i in range(10, 5):\n    print(i)\n</code></pre> <p>Neither of these snippets produces any error.</p> <pre><code>for i in range(0.0, 10.0):\n    print(i)\n</code></pre>"},{"location":"Notes/Section%203/Chapter%202/#iterating-through-strings","title":"Iterating through Strings","text":"<p>Since a string is a sequence of characters, we can use the <code>for</code> loop to iterate through strings. The following code will print each character of the string <code>x</code> in one line:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_6","title":"Code","text":"<pre><code>word = 'good'\nfor char in word:\n    print(char)\n</code></pre>"},{"location":"Notes/Section%203/Chapter%202/#output_1","title":"Output","text":"<pre><code>g\no\no\nd\n</code></pre> <p>We can add some more code to enrich the output:</p>"},{"location":"Notes/Section%203/Chapter%202/#code_7","title":"Code","text":"<pre><code>word = 'good'\ncount = 1\nfor char in word:\n    print(char, 'occurs at position', count, 'in the string', word)\n    count = count + 1\n</code></pre>"},{"location":"Notes/Section%203/Chapter%202/#output_2","title":"Output","text":"<pre><code>g occurs at position 1 in the string good\no occurs at position 2 in the string good\no occurs at position 3 in the string good\nd occurs at position 4 in the string good\n</code></pre>"},{"location":"Notes/Section%203/Chapter%203/","title":"Nested Loops in Python","text":""},{"location":"Notes/Section%203/Chapter%203/#problem-finding-ordered-pairs","title":"Problem: Finding Ordered Pairs","text":"<p>Consider the following problem:</p> <p>Find the number of ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.</p>"},{"location":"Notes/Section%203/Chapter%203/#solution","title":"Solution","text":"<pre><code>count = 0\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            count = count + 1\nprint(count)\n</code></pre> <p>The code above is an example of a nested loop. Lines 2-5 form the outer loop while lines 3-5 form the inner loop. There are multiple levels of indentation here:</p> <ul> <li>Line 3 begins a new <code>for</code> loop.</li> <li>Line 4 is indented with respect to line 3.</li> <li>Line 5 is indented with respect to line 4.</li> </ul> <p>This problem could have been solved without using a nested loop. The nested loop is not an efficient solution. It is left as an exercise to the reader to come up with a more efficient solution to this problem.</p>"},{"location":"Notes/Section%203/Chapter%203/#problem-counting-prime-numbers","title":"Problem: Counting Prime Numbers","text":"<p>Find the number of prime numbers less than n, where n is some positive integer.</p>"},{"location":"Notes/Section%203/Chapter%203/#solution_1","title":"Solution","text":"<pre><code>n = int(input())\ncount = 0\nfor i in range(2, n + 1):\n    flag = True\n    for j in range(2, i):\n        if i % j == 0:\n            flag = False\n            break\n    if flag:\n        count = count + 1\nprint(count)\n</code></pre>"},{"location":"Notes/Section%203/Chapter%203/#explanation","title":"Explanation","text":"<p>The basic idea behind the solution is as follows:</p> <ol> <li>The outer <code>for</code> loop goes through each element in the sequence 2, 3, ..., n. <code>i</code> is the loop variable for this sequence.</li> <li>We begin with the guess that <code>i</code> is prime. In code, we do this by setting <code>flag</code> to be <code>True</code>.</li> <li>Now, we go through all potential divisors of <code>i</code>. This is represented by the sequence 2, 3, ..., <code>i - 1</code>. Variable <code>j</code> is the loop variable for this sequence. Notice how the sequence for the inner loop is dependent on <code>i</code>.</li> <li>If <code>j</code> divides <code>i</code>, then <code>i</code> cannot be prime. We correct our initial assumption by updating <code>flag</code> to <code>False</code> whenever this happens. If <code>j</code> doesn't divide <code>i</code> for any <code>j</code>, then <code>i</code> is prime, and <code>flag</code> stays <code>True</code>.</li> <li>Once we are outside the inner loop, we check if <code>flag</code> is <code>True</code>. If that is the case, then we increment <code>count</code>, as we have hit upon a prime number.</li> </ol>"},{"location":"Notes/Section%203/Chapter%203/#important-points-about-nested-loops","title":"Important Points About Nested Loops","text":"<ul> <li>Nesting is not restricted to <code>for</code> loops. Any of the following combinations are possible:</li> <li><code>for</code> inside <code>for</code></li> <li><code>for</code> inside <code>while</code></li> <li><code>while</code> inside <code>while</code></li> <li><code>while</code> inside <code>for</code></li> <li>Multiple levels of nesting are possible.</li> </ul>"},{"location":"Notes/Section%203/Chapter%203/#while-vs-for-loops","title":"While vs. For Loops","text":"<p><code>for</code> loops are typically used in situations where the number of iterations can be quantified, while <code>while</code> loops are used when the number of iterations cannot be quantified exactly.</p>"},{"location":"Notes/Section%203/Chapter%203/#example-for-loop","title":"Example: For Loop","text":"<pre><code>n = int(input())\nfor i in range(n):\n    print(i ** 2)\n</code></pre> <p>In this code, the number of iterations varies each time the code is run with a different input. However, given the knowledge of the input, the number of iterations is fixed.</p>"},{"location":"Notes/Section%203/Chapter%203/#example-while-loop","title":"Example: While Loop","text":"<pre><code>x = int(input())\nwhile x &gt; 0:\n    x = int(input())\n</code></pre> <p>In this case, the number of iterations can only be determined after it terminates. There is no way to quantify the number of iterations as an explicit function of user input.</p>"},{"location":"Notes/Section%203/Chapter%203/#print-function-end-and-sep","title":"Print Function: <code>end</code> and <code>sep</code>","text":""},{"location":"Notes/Section%203/Chapter%203/#problem-printing-numbers-from-1-to-n","title":"Problem: Printing Numbers from 1 to n","text":"<p>Accept a positive integer <code>n</code> as input and print all the numbers from 1 to <code>n</code> in a single line separated by commas.</p> <p>For a given value of <code>n</code>, say <code>n = 9</code>, we want the output to be:</p> <pre><code>1,2,3,4,5,6,7,8,9\n</code></pre>"},{"location":"Notes/Section%203/Chapter%203/#solution_2","title":"Solution","text":"<pre><code>n = int(input())\nfor i in range(1, n + 1):\n    print(i, end=',')\nprint(n)\n</code></pre> <p>For <code>n = 9</code>, this will give the required output:</p> <pre><code>1,2,3,4,5,6,7,8,9\n</code></pre> <p>The print function's default behavior is to append a newline after each output. By using the <code>end</code> argument, we can change this behavior.</p>"},{"location":"Notes/Section%203/Chapter%203/#example-of-end","title":"Example of <code>end</code>","text":"<pre><code>print()\nprint(end=',')\nprint(1)\nprint(1, end=',')\nprint(2, end=',')\nprint(3, end=',')\n</code></pre> <p>Output:</p> <pre><code>,1\n1,2,3,\n</code></pre>"},{"location":"Notes/Section%203/Chapter%203/#separator-with-sep","title":"Separator with <code>sep</code>","text":"<p>If multiple expressions are passed to the print function, it prints all of them in the same line, adding a space between adjacent expressions.</p>"},{"location":"Notes/Section%203/Chapter%203/#example","title":"Example:","text":"<pre><code>print('this', 'is', 'cool')\n</code></pre> <p>Output:</p> <pre><code>this is cool\n</code></pre> <p>If we do not want the space or want a different separator, we can use <code>sep</code>:</p> <pre><code>print('this', 'is', 'cool', sep=',')\n</code></pre> <p>Output:</p> <pre><code>this,is,cool\n</code></pre> <p>We could also have an empty string as the separator:</p> <pre><code>print('this', 'is', 'cool', sep='')\n</code></pre> <p>Output:</p> <pre><code>thisiscool\n</code></pre>"},{"location":"Notes/Section%203/Chapter%203/#using-end-and-sep-together","title":"Using <code>end</code> and <code>sep</code> Together","text":""},{"location":"Notes/Section%203/Chapter%203/#problem-print-pattern","title":"Problem: Print Pattern","text":"<p>Accept a positive integer <code>n</code>, which is also a multiple of 3, as input and print the following pattern:</p> <pre><code>|1,2,3|4,5,6|7,8,9|...|n - 2,n - 1,n|\n</code></pre> <p>For <code>n = 9</code>, we would like to print:</p> <pre><code>|1,2,3|4,5,6|7,8,9|\n</code></pre>"},{"location":"Notes/Section%203/Chapter%203/#solution_3","title":"Solution","text":"<pre><code>n = int(input())\nprint('|', end='')\nfor i in range(1, n + 1, 3):\n    print(i, i + 1, i + 2, sep=',', end='|')\nprint()\n</code></pre> <p>Notice that the <code>for</code> loop iterates in steps of 3 starting from 1. To print the comma-separated triplet <code>i,i + 1,i + 2</code>, <code>sep</code> is set to <code>,</code>. After printing each triplet, the symbol <code>|</code> is printed by setting <code>end</code> to <code>|</code>. The last print statement ensures the prompt moves to the next line once the pattern is printed. You can try removing the last line and see how that changes the output.</p>"},{"location":"Notes/Section%203/Chapter%204/","title":"Formatted Printing","text":"<p>Consider the following program:</p> <pre><code>name = input()\nprint('Hi,', name, '!')\n</code></pre> <p>When this code is executed with <code>Sachin</code> as the input, we get the following output:</p> <pre><code>Hi, Sachin !\n</code></pre> <p>This looks messy as there is an unwanted space after the name. This is a formatting issue. Python provides some useful tools to format text the way we want.</p>"},{"location":"Notes/Section%203/Chapter%204/#f-strings","title":"f-strings","text":"<p>The first method we will look at is called formatted string literals, or f-strings for short. Let us jump into the syntax:</p> <pre><code>name = input()\nprint(f'Hi, {name}!')\n</code></pre> <p>When this code is executed with <code>Sachin</code> as the input, we get the following output:</p> <pre><code>Hi, Sachin!\n</code></pre> <p>The messy formatting has been corrected. Let us take a closer look at the string inside the print command:</p> <pre><code>f'Hi, {name}'\n</code></pre> <p>This is called a formatted string literal, or f-string. The <code>f</code> in front of the string differentiates f-strings from normal strings. An f-string is an object that, when evaluated, results in a string. The value of the variable <code>name</code> is inserted in place of <code>{name}</code> in the f-string.</p> <p>Two things are important for f-strings to work correctly:</p> <ol> <li>The <code>f</code> in front of the string.</li> <li>The curly braces <code>{}</code> enclosing the variable.</li> </ol> <p>Let us see what happens if we miss one of these two:</p> <pre><code>name = 'Sachin'\nprint('Hi, {name}!')\nprint(f'Hi, name!')\n</code></pre> <p>This will give the output:</p> <pre><code>Hi, {name}!\nHi, name!\n</code></pre> <p>Let us now look at a few other examples:</p> <pre><code>l, b = int(input()), int(input())\nprint(f'The length of the rectangle is {l} units')\nprint(f'The breadth of the rectangle is {b} units')\nprint(f'The area of the rectangle is {l * b} square units')\n</code></pre> <p>For <code>l = 4</code>, <code>b = 5</code>, the output is:</p> <pre><code>The length of the rectangle is 4 units\nThe breadth of the rectangle is 5 units\nThe area of the rectangle is 20 square units\n</code></pre> <p>Notice that line-4 has an expression \u2014 <code>l * b</code> \u2014 inside the curly braces, not just a variable. f-strings allow any valid Python expression inside the curly braces. If the f-string has some <code>{expression}</code> in it, the interpreter will substitute the value of the expression.</p> <p>Another example:</p> <pre><code>x = int(input())\nprint(f'Multiplication table for {x}')\nfor i in range(1, 11):\n    print(f'{x} X {i} \\t=\\t {x * i}')\n</code></pre> <p>For an input of <code>3</code>, this will give the following result:</p> <pre><code>Multiplication table for 3\n3 X 1   =    3\n3 X 2   =    6\n3 X 3   =    9\n3 X 4   =    12\n3 X 5   =    15\n3 X 6   =    18\n3 X 7   =    21\n3 X 8   =    24\n3 X 9   =    27\n3 X 10  =    30\n</code></pre> <p>The <code>\\t</code> is a tab character. It has been added before and after the <code>=</code>. Remove both tabs and run the code to observe any changes in the output.</p> <p>Till now, we have used f-strings within the <code>print</code> statement. Nothing stops us from using them to define other string variables:</p> <pre><code>name = input()\nqual = input()\ngender = input()\nif qual == 'phd':\n    name_respect = f'Dr. {name}'\nelif gender == 'male':\n    name_respect = f'Mr. {name}'\nelif gender == 'female':\n    name_respect = f'Ms. {name}'\nprint(f'Hello, {name_respect}')\n</code></pre> <p>Try to guess what this code is doing.</p>"},{"location":"Notes/Section%203/Chapter%204/#format","title":"<code>format()</code>","text":"<p>Another way to format strings is by using a string method called <code>format()</code>.</p> <pre><code>name = input()\nprint('Hi, {}!'.format(name))\n</code></pre> <p>In the above string, the curly braces <code>{}</code> will be replaced by the value of the variable <code>name</code>. Another example:</p> <pre><code>l, b = int(input()), int(input())\nprint('The length of the rectangle is {} units'.format(l))\nprint('The breadth of the rectangle is {} units'.format(b))\nprint('The area of the rectangle is {} square units'.format(l * b))\n</code></pre> <p>Let us now print the multiplication table using <code>format</code>:</p> <pre><code>x = int(input())\nfor i in range(1, 11):\n    print('{} X {} \\t=\\t {}'.format(x, i, x * i))\n</code></pre> <p>The output will be identical to the one we saw with f-strings.</p>"},{"location":"Notes/Section%203/Chapter%204/#format-specifiers","title":"Format Specifiers","text":"<p>Consider the following code:</p> <pre><code>pi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx}')\n</code></pre> <p>This gives the following output:</p> <pre><code>The value of pi is approximately 3.142857142857143\n</code></pre> <p>There are too many numbers after the decimal point. Format specifiers are a way to solve this problem:</p> <pre><code>pi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.2f}')\n</code></pre> <p>This gives the following output:</p> <pre><code>The value of pi is approximately 3.14\n</code></pre>"},{"location":"Notes/Section%203/Chapter%204/#example","title":"Example","text":"<p>Let us print the marks of three students in a class with right alignment:</p> <pre><code>roll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1:10.2f}')\nprint(f'{roll_2}: {marks_2:10.2f}')\nprint(f'{roll_3}: {marks_3:10.2f}')\n</code></pre> <p>This produces the output:</p> <pre><code>BSC1001:      90.50\nBSC1002:     100.00\nBSC1003:      90.15\n</code></pre> <p>The <code>10.2f</code> in <code>{marks_1:10.2f}</code> specifies that the float should be rounded to two decimal places, with a minimum width of 10.</p> <p>Another example with integers:</p> <pre><code>print('{0:5d}'.format(1))\nprint('{0:5d}'.format(11))\nprint('{0:5d}'.format(111))\nprint('{:5d}'.format(1111))\nprint('{:5d}'.format(11111))\nprint('{:5d}'.format(111111))\n</code></pre> <p>This gives the following output:</p> <pre><code>    1\n   11\n  111\n 1111\n11111\n111111\n</code></pre>"},{"location":"Notes/Section%203/Chapter%204/#points-to-note","title":"Points to Note","text":"<ul> <li><code>d</code> stands for integer.</li> <li><code>5d</code> after <code>:</code> specifies a minimum column width of 5.</li> </ul>"},{"location":"Notes/Section%203/Chapter%205/","title":"Library","text":"<p>We will look at two more libraries \u2014 <code>math</code> and <code>random</code> \u2014 and use them to solve some fascinating problems in mathematics.</p>"},{"location":"Notes/Section%203/Chapter%205/#math","title":"<code>math</code>","text":"<p>Consider the following sequence:</p> <p>Mathematically, it is known that this sequence converges or approaches a specific value. In other words, this sequence gets closer and closer to a well-defined number as more terms are added. This number is called the limit of the sequence. What is the limit for the above sequence? Can we use whatever we have learned so far to estimate this value?</p> <pre><code>import math\nx = 0\nfor n in range(1, 6):\n    x = math.sqrt(2 + x)\n    print(f'n = {n}, x_n = {x:.3f}')\n</code></pre> <p>If we execute the above code, we get the following output:</p> <pre><code>n = 1, x_n = 1.414\nn = 2, x_n = 1.848\nn = 3, x_n = 1.962\nn = 4, x_n = 1.990\nn = 5, x_n = 1.998\n</code></pre> <p>The <code>sqrt</code> function in the <code>math</code> library returns the square root of the number that is entered as an argument. Representing the output as a table:</p> <p>| Approximate Value | | ----------------- | ----- | | 1                 | 1.414 | | 2                 | 1.848 | | 3                 | 1.962 | | 4                 | 1.990 | | 5                 | 1.998 |</p> <p>Isn't that beautiful? It looks like this sequence \u2014 the train of square roots \u2014 is approaching the value 2. Let us run the loop for more iterations:</p> <pre><code>import math\nx = 0\nfor n in range(1, 20):\n    x = math.sqrt(2 + x)\nprint(x)\n</code></pre> <p>After just 20 iterations, the value is so close to two: <code>1.9999999999910236</code>. But we have used trial and error to decide when to terminate the iteration. A better way to do this is to define a tolerance: if the difference between the previous value and the current value in the sequence is less than some predefined value (tolerance), we terminate the iteration.</p> <pre><code>import math\nx_prev, x_curr = 0, math.sqrt(2)\ntol, count = 0.00001, 0\nwhile abs(x_curr - x_prev) &gt;= tol:\n    x_prev = x_curr\n    x_curr = math.sqrt(2 + x_prev)\n    count += 1\nprint(f'Value of x at {tol} tolerance is {x_curr}')\nprint(f'It took {count} iterations')\n</code></pre>"},{"location":"Notes/Section%203/Chapter%205/#random","title":"<code>random</code>","text":"<p>How do we toss a coin using Python?</p> <pre><code>import random\nprint(random.choice('HT'))\n</code></pre> <p>That's all there is to it! <code>random</code> is a library and <code>choice</code> is a function within it. It accepts any sequence as input and returns an element chosen at random from this sequence. In this case, the input is a string, which is a sequence of characters.</p> <p>We know that the probability of obtaining a head on a coin toss is 0.5. This is the theory. Is there a way to see this rule in action? We can computationally verify if this is indeed the case by setting up an experiment. Toss a coin <code>n</code> times and count the number of heads. Dividing the total number of heads by <code>n</code> will give the empirical probability. As <code>n</code> becomes large, this probability should approach 0.5.</p> <pre><code>import random\nn = int(input())\nheads = 0\nfor i in range(n):\n    toss = random.choice('HT')\n    if toss == 'H':\n        heads += 1\nprint(f'P(H) = {heads / n}')\n</code></pre> <p>Running the above code for different values of <code>n</code> and tabulating our results:</p> <code>n</code> <code>P(H)</code> 10 0.2 100 0.52 1,000 0.517 10,000 0.5033 100,000 0.49926 1,000,000 0.499983 <p>The value is approaching 0.5 as expected! <code>random</code> is quite versatile. Let us now roll a dice!</p> <pre><code>import random\nprint(random.randint(1, 6))\n</code></pre> <p><code>randint(a, b)</code> returns a random integer <code>x</code> such that <code>a &lt;= x &lt;= b</code>. We can conduct a similar experiment to find the probability of obtaining a specific number, say 1, when a dice is thrown.</p>"},{"location":"Notes/Section%203/Chapter%206/","title":"Math And Programming","text":"<p>Before closing this chapter, let us spend some time at the intersection of mathematics and programming.</p>"},{"location":"Notes/Section%203/Chapter%206/#limits","title":"Limits","text":"<p>Consider the following number:</p> <p>It is known that ( \\sqrt{2} - 1 ). From this, it follows that ( \\sqrt{2} - 1 &lt; 1 ). Now, consider the following sequence:</p> <p>As ( n ) becomes very large, the values in this sequence will become smaller and smaller. This is because if you keep multiplying a fraction by itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as ( n ) tends to infinity is zero. Let us verify this programmatically:</p> <pre><code>import math\nn = int(input())                # sequence length\nCONST = math.pow(2, 0.5) - 1    # basic term in the sequence\na_n = 1                         # zeroth term\nfor i in range(n):\n    a_n = a_n * CONST           # computing the nth term\nprint(a_n)\n</code></pre> <p>Try this out for a few values of ( n ). For ( n = 50 ), the value is approximately ( 1.4210854715202342 \\times 10^{-14} ), which is so small that for all practical purposes, it is as good as zero.</p>"},{"location":"Notes/Section%203/Chapter%206/#recurrence-relation","title":"Recurrence Relation","text":"<p>Now, here is another fact. For every number ( n ), there are unique integers ( x_n ) and ( y_n ) such that:</p> <p>[ xn = 2y{n-1} - x{n-1} \\quad \\text{and} \\quad y_n = x{n-1} - y_{n-1} ]</p> <p>For ( n = 1 ), this is obvious: ( x_1 = -1 ) and ( y_1 = 1 ). What about higher values of ( n )? We can prove this using mathematical induction. The following is a sketch of the inductive proof. If ( n \\geq 1 ), then:</p> <p>The equations given above define what is called a recurrence relation: each new term in the sequence is a function of the preceding terms. In this sequence, we have ( x_n ) and ( y_n ) defined as above. For ( n ), the pair of equations forms the recurrence relation:</p> <pre><code>n = int(input())    # sequence length\nx_n, y_n = -1, 1    # x_1 and y_1\nfor i in range(n - 1):\n    x_n, y_n = 2 * y_n - x_n, x_n - y_n\n</code></pre>"},{"location":"Notes/Section%203/Chapter%206/#rational-approximation","title":"Rational Approximation","text":"<p>This provides a way to approximate ( \\sqrt{2} ) using rational numbers:</p> <p>As ( n ) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places!</p> <p>Is any of this useful? I don't know. But honestly, who cares? We don't do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point in the future.</p>"},{"location":"Notes/Section%204/Chapter%201/","title":"Functions","text":""},{"location":"Notes/Section%204/Chapter%201/#introduction","title":"Introduction","text":"<p>In mathematics, a function is an object that accepts one or more inputs and produces one or more outputs. For example, ( f(x) = x^2 ) is a function that accepts a number and returns the square of that number. Functions in Python play a similar role, but are much richer than their mathematical counterparts. Let us quickly convert the mathematical function ( f ) into a Python function:</p> <pre><code>def f(x):\n    y = x ** 2\n    return y\n</code></pre> <pre><code>The code given above is called the definition of function `f`. The keyword `def` is used to define functions. `f` is the name of the function. `x` is a parameter of the function. Lines 2 and 3 make up the body of the function and are indented. The body of a function is a collection of statements that describe what the function does. At line 3, the value stored in variable `y` is returned. The keyword `return` is used for this purpose.\n\nIf we run the above code, we will not get any output. Functions are not executed unless they are called. The following code demonstrates what a function call looks like:\n\n```python\ndef square(x):\n    y = x ** 2\n    return y\n\nprint(square(2))\n```\n\nThe output is:\n\n```\n4\n```\n\n`square(2)` is a function call. We use the name of the function, `square`, and pass the number `2` as an argument to it. The `x` in the function definition is called the parameter. The value that is passed to the function in the call is called the argument. This is a convention that we will follow throughout this lesson.\n\n### A mental model to understand functions:\n\n- **Parameters** can be thought of as the function's inputs.\n- The **body of the function** can be pictured as the sequence of steps that transform the input into the output.\n- The **return statement** can be thought of as a means of communicating the output to the rest of the code.\n\n## Examples\n\nWe will look at a wide variety of function definitions. The focus will be on the syntactical aspects of function definitions.\n\n### Functions with Multiple Parameters\n\n```python\n# This function computes the area of a rectangle.\n# Length and breadth are the parameters\ndef area(l, b):\n    return l * b\n```\n\n### Functions with No Parameters\n\n```python\ndef foo():\n    return \"I don't like arguments visiting me!\"\n```\n\n### Functions with No Return Value\n\n```python\ndef foo():\n    print(\"I don't like talking to the outside world!\")\n\nfoo()\n```\n\nWhen the code given above is executed, we get the following output:\n\n```\nI don't like talking to the outside world!\n```\n\nNote that we didn't have to type `print(foo())`. We just had to call the function \u2014 `foo()` \u2014 since it already has the print statement inside it. But what happens if we type `print(foo())`? We get the following output:\n\n```\nI don't like talking to the outside world!\nNone\n```\n\nIf no explicit return statement is present in a function, `None` is the default value returned by it. When the interpreter comes across the `print(foo())` statement, first the function `foo()` is evaluated. This results in the first line of the output. Since `foo()` has no explicit return statement, it returns `None` by default. That is why the second line in the output is `None`.\n\n### A Minimal Python Function\n\n```python\ndef foo():\n    pass\n```\n\n`pass` is a keyword in Python. When the interpreter comes across a `pass` statement, it doesn't perform any computation and moves on to the next line. The reason this is minimal is that it has only those features that are absolutely essential for a function definition to be syntactically valid: function name and at least one statement in the body.\n\nSuch functions might seem useless at first sight, but they do have their place in programming. While writing a complex piece of code, a coder may realize that she needs to define a function to perform a specific task. But she may not know the exact details of the implementation, or it may not be an urgent requirement. In such a scenario, she will add a minimal function like the one given above in her code and name it appropriately. Implementing this function will become a task on her to-do list and will be taken up as and when the need arises.\n\n### Functions with Multiple Return Statements\n\nFunctions could have multiple return statements, but the moment the first return is executed, control exits from the function:\n\n```python\ndef foo():\n    return 1\n    return 2\n```\n\n`foo()` will always return `1`. Line 3 is redundant. An example of a function having multiple returns that are not redundant:\n\n```python\ndef evenOrOdd(n):\n    if n % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'\n```\n\n```python\nprint(evenOrOdd(10))\nprint(evenOrOdd(11))\n```\n\nThe output is:\n\n```\neven\nodd\n```\n\nWhen `evenOrOdd` is called with an even number as an argument, the return statement in line 3 is executed. When the same function is called with an odd number as an argument, the return statement in line 5 is executed.\n\n### Functions that Return Multiple Values\n\n```python\n# Accept only positive floating point numbers\ndef bound(x):\n    lower = int(x)\n    upper = lower + 1\n    return lower, upper\n```\n\n```python\ny = 7.3\nl, u = bound(y)\nprint(f'{l} &lt; {y} &lt; {u}')\n```\n\nThe exact mechanism of what happens here will become clear when we come to the lesson on tuples. In line 8, the first value returned by `bound` is stored in `l`, and the second value returned by `bound` is stored in `u`.\n\n### Function Definition Order\n\nFunctions have to be defined before they can be called. The function call cannot come before the definition. For example:\n\n```python\n##### Alarm! Wrong code snippet! #####\nprint(f(5))\n\ndef f(x):\n    return x ** 2\n##### Alarm! Wrong code snippet! #####\n```\n\nWhen the above code is executed, it throws a `NameError`. Why does this happen? The Python interpreter executes the code from top to bottom. At line 2, `f` is a name that the interpreter has never seen before, and therefore it throws a `NameError`. Recall that `NameError` occurs when we try to reference a name that the interpreter has not seen before.\n\n### Function Calls in Expressions\n\n```python\ndef square(a):\n    return a ** 2\n\nx, y, z = int(input()), int(input()), int(input())\nif square(x) + square(y) == square(z):\n    print(f'{x}, {y} and {z} form the sides of a right triangle with {z} as the hypotenuse')\n```\n\n### Function Calls Cannot Be Assigned Values\n\n```python\n##### Alarm! Wrong code snippet! #####\ndef foo():\n    return True\n\nfoo() = 1\n##### Alarm! Wrong code snippet! #####\n```\n\nThe above code throws a `SyntaxError`.\n\n### Nested Function Calls\n\nFunctions can be called from within other functions:\n\n```python\ndef foo():\n    print('I am inside foo')\n\ndef bar():\n    print('I am inside bar')\n    print('I am going to call foo')\n    foo()\n\nprint('I am outside both foo and bar')\nbar()\nprint('I am outside both foo and bar')\n```\n\n### Defining Functions Inside Other Functions\n\nFunctions can be defined inside other functions:\n\n```python\ndef foo():\n    def bar():\n        print('bar is inside foo')\n    bar()\n\nfoo()\n```\n\nTry calling `bar()` outside `foo`. What do you observe?\n\n## Docstrings\n\nConsider the following function:\n\n```python\ndef square(x):\n    \"\"\"Return the square of x.\"\"\"\n    return x ** 2\n```\n\nThe string immediately below the function definition is called a docstring. From the Python docs:\n\nA docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the `__doc__` special attribute of that object.\n\nIgnore unfamiliar terms such as \"module\" and \"class.\" For now, it is sufficient to focus on functions. Adding the docstring to functions is a good practice. It may not be needed for simple and obvious functions like the one defined above. As the complexity of the functions you write increases, docstrings can be a lifesaver for other programmers reading your code.\n\nThe docstring associated with a given function can be accessed using the `__doc__` attribute:\n\n```python\nprint(square.__doc__)\n```\n\nThis gives `'Return the square of x.'` as output.\n</code></pre>"},{"location":"Notes/Section%204/Chapter%202/","title":"Chapter 2","text":""},{"location":"Notes/Section%204/Chapter%202/#arguments","title":"Arguments","text":"<p>Python offers various options for how arguments can be passed to functions. Each method of argument passing addresses the following question:</p> <p>How are the arguments in the function call passed to the parameters in the function definition?</p>"},{"location":"Notes/Section%204/Chapter%202/#positional-arguments","title":"Positional Arguments","text":"<p>All functions that we have seen so far use positional arguments. Here, the position of an argument in the function call determines which parameter it is passed to. For example:</p> <p>Problem: Write a function that accepts three positive integers ( x ), ( y ), and ( z ). Return <code>True</code> if the integers form the sides of a right triangle with ( x ) and ( y ) as the legs and ( z ) as the hypotenuse, and <code>False</code> otherwise.</p> <p>Solution:</p> <pre><code>def isRight(x, y, z):\n    if x ** 2 + y ** 2 == z ** 2:\n        return True\n    return False\n\nprint(isRight(3, 4, 5))  # 3 is passed to x, 4 to y, 5 to z\nprint(isRight(5, 4, 3))  # 5 is passed to x, 4 to y, 3 to z\n</code></pre> <p>Output:</p> <pre><code>True\nFalse\n</code></pre> <p>Arguments are passed to the parameters based on their position in the function call. Positional arguments are also known as required arguments; they cannot be omitted. Attempting to provide more arguments than there are parameters will result in an error. For example, executing the following code will produce an error:</p> <pre><code># Alarm! Wrong code snippet!\nisRight(3, 4)\nisRight(3, 4, 5, 6)\n# Alarm! Wrong code snippet!\n</code></pre>"},{"location":"Notes/Section%204/Chapter%202/#keyword-arguments","title":"Keyword Arguments","text":"<p>Keyword arguments introduce more flexibility in passing arguments. Consider the same problem from above, modified to use keyword arguments:</p> <pre><code># The following is just a function call.\n# We are not printing anything here.\nisRight(x=3, y=4, z=5)\n</code></pre> <p>In this call, the names of the parameters are explicitly specified, and the arguments are assigned using the <code>=</code> operator. This differs from positional arguments, where the position in the call determines the parameter. An advantage of keyword arguments is that they reduce the likelihood of incorrect order. For example:</p> <pre><code>isRight(3, 4, 5)          # Intended call\nisRight(5, 4, 3)          # Actual call\nisRight(x=3, y=4, z=5)    # Same as intended call\nisRight(z=5, y=4, x=3)    # Same as intended call\n</code></pre> <p>Positional and keyword arguments can be combined in a single call:</p> <pre><code>isRight(3, y=4, z=5)\n</code></pre> <p>However, you cannot do the following:</p> <pre><code># Alarm! Wrong code snippet!\nisRight(x=3, 4, 5)\n# Alarm! Wrong code snippet!\n</code></pre> <p>The interpreter throws a <code>TypeError</code>: \"positional argument follows keyword arguments.\" When both types are present, keyword arguments must come last.</p> <p>Consider this call:</p> <pre><code># Alarm! Wrong code snippet!\nisRight(3, x=3, y=4, z=5)\n# Alarm! Wrong code snippet!\n</code></pre> <p>This will throw a <code>TypeError</code>: \"isRight() got multiple values for argument x.\" Only one argument can be passed for each parameter in the function definition, whether positional or default, but not both.</p>"},{"location":"Notes/Section%204/Chapter%202/#default-arguments","title":"Default Arguments","text":"<p>Let\u2019s consider a scenario with two distance metrics: Euclidean and Manhattan. Assume a self-driving car startup uses these metrics repeatedly in its code base. You can represent them as functions:</p> <pre><code>def euclidean(x, y):\n    return pow(x ** 2 + y ** 2, 0.5)\n\ndef manhattan(x, y):\n    return abs(x) + abs(y)\n</code></pre> <p>However, since the Manhattan distance is used more frequently, default arguments can help streamline the function:</p> <pre><code>def distance(x, y, metric='manhattan'):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\n</code></pre> <p>In this case, the <code>metric</code> parameter has a default value of <code>'manhattan'</code>. If we call the function without specifying this parameter:</p> <pre><code>print(distance(3, 4))\n</code></pre> <p>This outputs <code>7</code>, as the default value of <code>'manhattan'</code> is used.</p> <p>Key points regarding default parameters:</p> <ul> <li>Parameters assigned a value in the function definition are called default parameters.</li> <li>Default parameters must always be at the end of the parameter list.</li> <li>Arguments for default parameters are optional in a function call.</li> <li>Arguments for default parameters can be passed as positional or keyword arguments.</li> </ul> <p>Here are examples of valid function calls with default parameters:</p> <pre><code>distance(3, 4)\ndistance(3, 4, 'manhattan')\ndistance(3, 4, metric='manhattan')\n</code></pre> <p>All three calls are equivalent.</p>"},{"location":"Notes/Section%204/Chapter%202/#call-by-value","title":"Call by Value","text":"<p>Consider the following code:</p> <pre><code>def double(x):\n    x = x * 2\n    return x\n\na = 4\nprint(f'before function call, a = {a}')\ndouble(a)\nprint(f'after function call, a = {a}')\n</code></pre> <p>Output:</p> <pre><code>before function call, a = 4\nafter function call, a = 4\n</code></pre> <p>Here, the value of <code>a</code> remains unchanged after the function call. When <code>double(a)</code> is invoked, the value in <code>a</code> is assigned to the parameter <code>x</code> in the function. This kind of function call, where the value of a variable is passed as an argument, is called call by value.</p> <p>Now consider this example:</p> <pre><code>def square(x):\n    return x * x\n\nx = 10\nx_squared = square(x)\n</code></pre> <p>Using the same name for both the parameter of the function and the argument passed is not advisable. It\u2019s better to differentiate the names to avoid confusion and improve code readability. The above code could be rewritten as follows:</p> <pre><code>def square(num):\n    return num * num\n\nx = 10\nx_squared = square(x)\n</code></pre>"},{"location":"Notes/Section%204/Chapter%203/","title":"Chapter 3","text":""},{"location":"Notes/Section%204/Chapter%203/#scope","title":"Scope","text":"<ul> <li>Definition: The scope of a variable determines where it can be accessed or modified in the code.</li> <li>Local Scope: Variables defined inside a function (like <code>x</code> in <code>foo()</code>) are local to that function and cannot be accessed from outside it. Attempting to do so will raise a <code>NameError</code>.</li> <li>Global Scope: Variables defined outside any function (like <code>y</code> in the second example) can be accessed within functions as long as they are defined before the function call. If a variable is only referenced and not assigned within a function, it is treated as global.</li> </ul>"},{"location":"Notes/Section%204/Chapter%203/#local-vs-global-variables","title":"Local vs Global Variables","text":"<ul> <li>Local Variables: Assigned within a function. If you create a variable inside a function, it only exists there.</li> <li>Global Variables: Can be referenced anywhere in the code after being defined. However, if you define a variable with the same name inside a function, it will shadow the global variable.</li> </ul>"},{"location":"Notes/Section%204/Chapter%203/#example-analysis","title":"Example Analysis","text":"<ol> <li>Local Variable Example:</li> </ol> <pre><code>def foo():\n    x = 1\n    print(x)  # Works fine\nfoo()\nprint(x)  # Raises NameError\n</code></pre> <p>In this case, <code>x</code> is local to <code>foo()</code>.</p> <ol> <li>Global Variable Example:</li> </ol> <pre><code>y = 10\ndef foo():\n    print(y)  # Works fine, y is global\nfoo()\n</code></pre> <ol> <li>Shadowing:    <pre><code>def foo():\n    x = 10\n    print(f'x inside foo = {x}')  # Local x\nx = 100\nfoo()\nprint(f'x outside foo = {x}')  # Global x\n</code></pre></li> </ol>"},{"location":"Notes/Section%204/Chapter%203/#namespaces","title":"Namespaces","text":"<ul> <li>Definition: A namespace is a container where names (variables, functions) are mapped to objects. It allows for organized management of variable names in different scopes.</li> <li>Global Namespace: Contains all names defined at the top level of the script.</li> <li>Local Namespace: Created when a function is called and contains names defined within that function.</li> </ul>"},{"location":"Notes/Section%204/Chapter%203/#accessing-namespaces","title":"Accessing Namespaces","text":"<ul> <li>The Python interpreter follows a specific order to resolve names:</li> <li>Local namespace of the current function.</li> <li>Global namespace of the module.</li> <li>Built-in namespace.</li> </ul>"},{"location":"Notes/Section%204/Chapter%203/#the-global-keyword","title":"The <code>global</code> Keyword","text":"<ul> <li>Used to declare that a variable inside a function is global and should not be treated as local. This allows you to modify the global variable inside the function.</li> </ul>"},{"location":"Notes/Section%204/Chapter%203/#built-in-functions","title":"Built-in Functions","text":"<ul> <li>Built-in functions like <code>print</code>, <code>int</code>, etc., reside in the built-in namespace. It's possible to override these names by assigning them new values, but doing so is discouraged as it can lead to errors and unexpected behavior.</li> </ul>"},{"location":"Notes/Section%204/Chapter%203/#example-of-built-in-function-override","title":"Example of Built-in Function Override","text":"<pre><code>print = 1  # Overrides the built-in print function\nprint(1)  # Raises TypeError\n</code></pre> <p>This kind of practice is strongly discouraged because it can lead to code that is difficult to debug and maintain.</p>"},{"location":"Notes/Section%204/Chapter%203/#summary","title":"Summary","text":"<p>Understanding scope, local vs. global variables, and namespaces is crucial for writing effective Python code. Proper use of these concepts helps prevent errors and makes code more readable and maintainable. Always be cautious with variable names, especially when dealing with built-in functions.</p>"},{"location":"Notes/Section%204/Chapter%204/","title":"Chapter 4","text":""},{"location":"Notes/Section%204/Chapter%204/#function-calling","title":"Function Calling","text":"<ol> <li> <p>Basic Function Calls:</p> </li> <li> <p>The example demonstrates how functions can call each other. When <code>first()</code> is executed, it calls <code>second()</code>, which in turn calls <code>third()</code>.</p> </li> <li> <p>The output order is <code>third</code>, <code>second</code>, <code>first</code>, illustrating the call stack: the last function called completes first, and control returns to the previous function.</p> </li> <li> <p>Traffic-Signal Method:</p> </li> <li> <p>Functions can be in three states: ongoing, suspended, or completed.</p> <ul> <li>Ongoing: When control is inside the function and executing code.</li> <li>Completed: When all lines have been executed, and control has exited the function.</li> <li>Suspended: When a function calls another function and awaits its completion.</li> </ul> </li> <li> <p>Stack Representation:</p> </li> <li>The stack visualizes the state of function calls at different times, showing how control flows between functions as they complete.</li> </ol>"},{"location":"Notes/Section%204/Chapter%204/#recursion","title":"Recursion","text":"<ol> <li> <p>Recursive Functions:</p> </li> <li> <p>A function that calls itself, such as the factorial function <code>fact()</code>.</p> </li> <li> <p>It includes a base case to terminate recursion; without it, recursion can lead to infinite calls.</p> </li> <li> <p>Example of Factorial Calculation:</p> </li> <li> <p>The function halts execution temporarily to execute <code>fact(n - 1)</code> until reaching <code>fact(0)</code>, which returns <code>1</code>, allowing the stack to unwind.</p> </li> <li> <p>Fibonacci Series:</p> </li> <li> <p>Demonstrates another recursive function, <code>fibo()</code>, to compute Fibonacci numbers.</p> </li> <li> <p>The naive recursive implementation can lead to excessive computation and inefficiency due to repeated calculations of the same values (e.g., <code>fibo(2)</code> is calculated multiple times).</p> </li> <li> <p>Performance Measurement:</p> </li> <li> <p>The time taken for a function to run can be measured using the <code>time</code> library.</p> </li> <li> <p>The naive recursive solution for Fibonacci is inefficient, especially for large inputs.</p> </li> <li> <p>Iterative Solution:</p> </li> <li>An iterative approach to the Fibonacci series avoids the inefficiency of recursion by maintaining state with variables.</li> </ol>"},{"location":"Notes/Section%204/Chapter%204/#counting-function-calls","title":"Counting Function Calls","text":"<ul> <li>A global variable can be used to count how many times a function has been called, demonstrated with the factorial example.</li> </ul>"},{"location":"Notes/Section%204/Chapter%204/#infinite-recursion-and-errors","title":"Infinite Recursion and Errors","text":"<ol> <li>Pathological Recursion:</li> <li>A function without a base case can lead to a <code>RecursionError</code> due to exceeding the maximum recursion depth (typically 1000 in Python).</li> <li>Checking the recursion limit can be done using <code>sys.getrecursionlimit()</code>.</li> </ol>"},{"location":"Notes/Section%204/Chapter%204/#summary","title":"Summary","text":"<ul> <li>This content serves as an introduction to understanding function calls and recursion in Python. It explains key concepts such as the call stack, function states, recursive versus iterative approaches, performance issues, and potential pitfalls like infinite recursion.</li> </ul>"},{"location":"Notes/Section%205/Chapter%201/","title":"Lists","text":""},{"location":"Notes/Section%205/Chapter%201/#introduction","title":"Introduction","text":"<p>A list in Python is a data structure that is used to store a sequence of objects. Some examples are given below:</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nletters = ['a', 'b', 'c', 'd']\nwords = ['this', 'is', 'a', 'list']\n</code></pre> <p>Lists can be printed, just like the other types we have seen so far. <code>print(numbers)</code> will give the following output:</p> <pre><code>[1, 2, 3, 4, 5]\n</code></pre> <p>Lists could contain objects of different types. Python permits lists such as this:</p> <pre><code>mixture = [1, 1.0, '1', True]\n</code></pre> <p>Lists have a separate type - <code>list</code>. We can also check if a given variable holds an object of type list:</p> <pre><code>numbers = [1, 2, 3]\nprint(type(numbers))\nprint(isinstance(numbers, list))\n</code></pre> <p>The <code>len</code> function can be used to find the number of elements in a list:</p> <pre><code>numbers = [1, 2, 3]\nprint(f'This list has {len(numbers)} elements in it')\n</code></pre> <p>Lists support indexing and slicing. These two operations work exactly the same way as they did for strings:</p> <pre><code>numbers = [1, 2, 3, 4]\nprint(numbers[0], numbers[1], numbers[2], numbers[3])\nprint(numbers[1:3])\nprint(numbers[-2])\n</code></pre>"},{"location":"Notes/Section%205/Chapter%201/#iterating-through-lists","title":"Iterating through lists","text":"<p>As a list is a sequence, we can iterate through it using <code>for</code>. This is one of the primary uses of the <code>for</code> loop:</p>"},{"location":"Notes/Section%205/Chapter%201/#method-1","title":"Method-1","text":"<pre><code>numbers = [1, 2, 3, 4]\nfor num in numbers:\n    print(num)\n</code></pre> <p>The loop variable \u2014 <code>num</code> \u2014 picks one item at a time from the sequence. In the body of the loop, we are just printing this item. We can rewrite the code given above using a <code>while</code> loop:</p>"},{"location":"Notes/Section%205/Chapter%201/#method-2","title":"Method-2","text":"<pre><code>numbers = [1, 2, 3, 4]\nindex = 0\nwhile index &lt; len(numbers):\n    print(numbers[index])\n    index += 1\n</code></pre> <p>Finally, we can also use the <code>for</code> loop to iterate through the indices of the list. For this, we take the help of the <code>range</code> function.</p>"},{"location":"Notes/Section%205/Chapter%201/#method-3","title":"Method-3","text":"<pre><code>numbers = [1, 2, 3, 4]\nfor index in range(len(numbers)):\n    print(numbers[index])\n</code></pre> <p>In the example given above, <code>len(numbers)</code> is equal to 4. So, the range sequence will be 0, 1, 2, 3. <code>index</code> is the loop variable that iterates through this sequence.</p> <p>Methods 2 and 3 are very similar. Both iterate through the sequence of indices, and use list indexing to access the corresponding element in the list. The only difference is that method-2 uses <code>while</code>, while method-3 uses <code>for</code>. Method-1 stands out from the other two as it directly pulls elements from the sequence.</p>"},{"location":"Notes/Section%205/Chapter%201/#growing-a-list","title":"Growing a list","text":"<p>Lists are typically used in problems where we wish to store a collection of items. Usually, we start with an empty list. Python provides two ways to create an empty list:</p> <pre><code>list1 = []\nlist2 = list()\n</code></pre> <p>Both <code>list1</code> and <code>list2</code> are empty lists. The interpreter doesn't mind spaces between the opening and closing braces, so <code>list1 = [  ]</code> also works. Given an empty list, how do we add items to it? Python provides two ways to do this:</p> <pre><code>list1 = list1 + [1]\nprint(list1)\nlist2.append(1)\nprint(list2)\n</code></pre> <p>Both lists end up having just the one element. The first method is called list concatenation, i.e., two lists are being concatenated or combined together. Treat concatenation like joining two compartments of a train together. It is very similar to string concatenation. The second way uses a method called <code>append</code> that is essentially a function defined for the list type. <code>append</code> adds elements at the end of the list.</p> <p>Consider the following problem:</p> <p>Generate the list of positive integers less than 100 that are divisible by 3.</p> <p>There are at least two ways of doing this. The first one uses <code>while</code>:</p>"},{"location":"Notes/Section%205/Chapter%201/#method-1_1","title":"Method-1","text":"<pre><code>num = 3\nnums_div = []\nwhile num &lt; 100:\n    nums_div.append(num)\n    num += 3\n</code></pre> <p>The next method uses <code>for</code>:</p>"},{"location":"Notes/Section%205/Chapter%201/#method-2_1","title":"Method-2","text":"<pre><code>nums_div = []\nfor num in range(3, 100, 3):\n    nums_div.append(num)\n</code></pre>"},{"location":"Notes/Section%205/Chapter%201/#operations-on-lists","title":"Operations on Lists","text":"<p>We have already seen how the <code>+</code> operator works with lists:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist12 = list1 + list2\nprint(list12)\nlist21 = list2 + list1\nprint(list21)\n</code></pre> <p>This gives the concatenated output:</p> <pre><code>[1, 2, 3, 4, 5, 6]\n[4, 5, 6, 1, 2, 3]\n</code></pre> <p>The order matters when two lists are being concatenated! The next is the <code>*</code> operator:</p> <pre><code>list1 = [0] * 5\nprint(list1)\nlist2 = [1, 2, 3] * 3\nprint(list2)\n</code></pre> <p>This replicates the list. The following is the output:</p> <pre><code>[0, 0, 0, 0, 0]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n</code></pre> <p>Two lists are equal if they have the same sequence of elements:</p> <pre><code>l1 = [1, 2, 3]\nl2 = [1, 2, 3]\nl3 = [3, 2, 1]\nprint(l1 == l2)\nprint(l2 == l3)\n</code></pre> <p>This results in:</p> <pre><code>True\nFalse\n</code></pre> <p>Finally, two lists can be compared with the <code>&gt;</code> or the <code>&lt;</code> operator. List comparison works very similarly to string comparison, in that it uses lexicographic ordering. We looked at this in the first chapter:</p>"},{"location":"Notes/Section%205/Chapter%201/#lexicographic-ordering","title":"Lexicographic ordering","text":"<p>First elements from both lists are compared. If they differ, this determines the outcome of the comparison. If they are equal, then the second elements of both lists are compared. This process continues until either list is exhausted.</p> <p>Some example comparisons:</p> <pre><code>print([1, 2] &lt; [2, 1])\nprint([1] &lt; [1, 2, 3])\nprint([2, 3, 4] &lt; [3])\nprint([] &lt; [1])\n</code></pre> <p>All four of them result in <code>True</code>.</p>"},{"location":"Notes/Section%205/Chapter%201/#useful-functions","title":"Useful Functions","text":"<p>Let us look at some built-in functions that operate on lists:</p> <ul> <li>sum: this is used to find the sum of the elements in a list of numbers:   <pre><code>a = [1, 2, 3]\nprint(sum(a))\n</code></pre></li> <li>max and min: these two functions find the maximum and minimum value in a list respectively.   <pre><code>a = [1, 2, 3]\nprint(min(a), max(a))\n</code></pre></li> </ul> <p>What happens if <code>a</code> is a list of strings? What would <code>max(a)</code> and <code>min(a)</code> produce?</p> <ul> <li>sorted: this function returns a sorted list   <pre><code>a = [2, 1, 3]\nprint(sorted(a))\n</code></pre></li> </ul> <p>We have come across the range object and seen how useful it was in iterating through a sequence. So far, <code>range</code> has been associated with the <code>for</code> loop. Its time has come to break out of the loopy prison:</p> <pre><code>numbers = range(10)\nprint(numbers)\n</code></pre> <p>This gives <code>range(0, 10)</code> as an output. This is a sequence that we can iterate over. Python provides a way of turning this object into a list:</p> <pre><code>numbers = list(range(10))\nprint(numbers)\n</code></pre> <p>This gives <code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code> as the output.</p>"},{"location":"Notes/Section%205/Chapter%202/","title":"Lists","text":""},{"location":"Notes/Section%205/Chapter%202/#mutability","title":"Mutability","text":"<p>Consider the following problem:</p> <p>Assume that you work at a company that analyzes cricket matches. As a part of the data collection process in the IPL, the data-processing team is tasked with recording the runs scored in every ball in every match. It is your colleague's turn to do the bookkeeping for the final match between CSK and MI. Just before the start, the \"0\" key on his keyboard stops functioning. As a workaround, you cleverly suggest that he use the letter \"O\" instead of 0. Once the match is over, you collect the list of runs scored. Write a program that replaces all appearances of the letter \"O\" with the number 0. I leave it to your imagination to decide who won the finals!</p>"},{"location":"Notes/Section%205/Chapter%202/#solution","title":"Solution","text":"<pre><code>runs = [1, 4, 2, 'O', 4, 'O']  # the data for one over is given here\nprint(runs)\nfor i in range(len(runs)):\n    if runs[i] == 'O':\n        runs[i] = 0\nprint(runs)\n</code></pre> <p>The most interesting line is the fifth one: <code>runs[i] = 0</code>. We are updating a list in-place. Python permits this operation because lists are mutable. Contrast this with strings that are immutable, which means that they cannot be updated in-place. Mutability makes lists powerful; but reckless exercise of power always results in instability as is demonstrated by this notorious example:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1)\nprint(list2)\n</code></pre> <p>Both give the same output even though we are only modifying <code>list2</code> in-place!</p> <pre><code>[100, 2, 3]\n[100, 2, 3]\n</code></pre> <p>What is happening here? To understand this, we will take the help of a built-in function called <code>id</code>. Every object in Python has a unique identity: if <code>x</code> is an object, then <code>id(x)</code> returns this object's identity. From the Python documentation, \"this is guaranteed to be unique among simultaneously existing objects\". In the implementation of the Python that we use, this unique id is nothing but the object's memory address.</p> <p>In line-2, we are not creating a new object. We are merely creating another name, also called an alias, for the same object. Think of this like having a nickname. Your name and nickname are two different words, but both of them refer to you. To see if two Python names point to the same object, we can use the <code>is</code> keyword:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1 is list2)\n</code></pre> <p>This prints <code>True</code>. Now consider another scenario:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = [1, 2, 3]\nprint(list1 == list2)\nprint(list1 is list2)\n</code></pre> <p>This gives the following output:</p> <pre><code>True\nFalse\n</code></pre> <p>This is because equality and identity are two different things. In the code, line-3 checks for equality of two lists, and line-4 checks if the two lists point to the same object. <code>list1</code> and <code>list2</code> point to two different objects and consequently have different identities. But, they store the same sequence of items and are hence equal.</p> <p>How do we create a copy of a list so that updating one doesn't end up changing both? Python provides three ways to do this:</p> <pre><code>list1 = [1, 2, 3]\nlist2 = list(list1)\nlist3 = list1[:]\nlist4 = list1.copy()\n\nlist2[0] = 100\nlist3[0] = 200\nlist4[0] = 300\n\nprint(list1, list2, list3, list4)\nprint(list1 is not list2, list1 is not list3, list1 is not list4)\n</code></pre> <p>This results in the following output:</p> <pre><code>[1, 2, 3] [100, 2, 3] [200, 2, 3] [300, 2, 3]\nTrue True True\n</code></pre> <p>In line-2, we pass <code>list1</code> as an argument to the <code>list</code> function, which returns a new list object with the same sequence of elements as <code>list1</code>.</p> <p>In line-3, we are slicing the list. Slicing a list results in a new list object. As no start or stop values are mentioned, they are going to default to 0 and <code>len(list1)</code> respectively. So, the entire list is returned. However, it is a brand new object.</p> <p>In line-4, we use a method call <code>copy</code> that is defined for the list object. Lines 10 and 11 verify that the methods used to copy lists in lines 2, 3, and 4 actually work.</p>"},{"location":"Notes/Section%205/Chapter%202/#call-by-reference","title":"Call by Reference","text":"<p>Mutability impacts the way lists are handled in functions. Consider these two snippets:</p>"},{"location":"Notes/Section%205/Chapter%202/#snippet-1","title":"Snippet-1","text":"<pre><code>def foo():\n    L.append(1)\n\nL = [0]\nprint(f'L before: {L}')\nfoo()\nprint(f'L after: {L}')\n</code></pre> <p>Snippet-1 doesn't have any parameters. Since <code>L</code> is not being assigned a new value inside <code>foo</code>, the scope of <code>L</code> remains global.</p>"},{"location":"Notes/Section%205/Chapter%202/#snippet-2","title":"Snippet-2","text":"<pre><code>def foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n\nL = [0]\nprint(f'L before: {L}')\nfoo(L)\nprint(f'L after: {L}')\n</code></pre> <p>Snippet-2 has <code>L_foo</code> as a parameter whose scope is local to <code>foo</code>. But note that modifying <code>L_foo</code> within the function changes <code>L</code> outside the function. This is because <code>L_foo</code> and <code>L</code> point to the same object. How did this aliasing happen? The function call at line-8 works something like an assignment statement: <code>L_foo = L</code>, so <code>L_foo</code> is just another name that refers to the object that <code>L</code> is bound to. This type of function call where a reference to an object is passed is termed call by reference. Whenever a mutable variable is passed as an argument to a function, the references to the corresponding object are passed.</p> <p>If all this seems too complicated, just remember that modifying mutable objects within a function produces side effects outside the function. What if we don't want these side effects? We have to create a new list object like we did before:</p> <pre><code>def foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n\nL = [0]\nprint(f'L before: {L}')\nfoo(list(L))\nprint(f'L after: {L}')\n</code></pre> <p><code>foo</code> doesn't produce any side effects. Line-7 could be replaced with <code>foo(L[:])</code> or <code>foo(L.copy())</code>.</p>"},{"location":"Notes/Section%205/Chapter%203/","title":"List Methods","text":""},{"location":"Notes/Section%205/Chapter%203/#insert","title":"insert","text":"<p>We have looked at list methods like <code>append</code>, <code>count</code>, and <code>index</code> so far. There are some more interesting methods that will come in handy. <code>insert</code> can be used to insert an element in a list at a given position:</p> <pre><code>L = [1, 1, 2, 3, 8]\nL.insert(4, 5)\nprint(L)\n</code></pre> <p><code>list.insert(index, object)</code> inserts the object before index in the list. In the code given above, the element 5 is inserted before the index 4 in the list L. Let us try a few more inserts:</p> <pre><code>L = [10, 20, 30]\nL.insert(0, 5)          # L becomes [5, 10, 20, 30]\nL.insert(2, 15)         # L becomes [5, 10, 15, 20, 30]\nL.insert(4, 25)         # L becomes [5, 10, 15, 20, 25, 30]\nL.insert(len(L), 35)    # L becomes [5, 10, 15, 20, 25, 30, 35]\nL.insert(20, 40)        # L becomes [5, 10, 15, 20, 25, 30, 35, 40]\n</code></pre> <p>If the index is greater than the length of the current list, then the element gets added to the end. <code>insert</code> is most useful when an element needs to be inserted at the beginning of a list. Inserting an element at the end can be done using <code>append</code>.</p>"},{"location":"Notes/Section%205/Chapter%203/#pop","title":"pop","text":"<p>Consider the following code:</p> <pre><code>L = ['a', 'b', 'c', 'd', 'e', 'f']\nindex = 1\nx = L.pop(index)\nprint(f'The element {x} at index {index} was removed from the list')\nprint(f'The current list is {L}')\n</code></pre> <p><code>L.pop(index)</code> removes the element at index in L and returns it. If no argument is provided to <code>pop</code>, index defaults to -1. Index is thus a default argument for the method <code>pop</code>. A default value of -1 means that the last element in the list is removed. To see this in action, execute the following code:</p> <pre><code>L = ['a', 'b', 'c', 'd', 'e', 'f']\nx = L.pop()\nprint(f'The current list is {L}')\n</code></pre> <p>What happens if you enter an index that is out of range?</p>"},{"location":"Notes/Section%205/Chapter%203/#reverse","title":"reverse","text":"<p>A list can be reversed in-place using the following method:</p> <pre><code>L = [1, 2, 3, 4, 5]\nprint('Before:', L, id(L))\nL.reverse()\nprint('After:', L, id(L))\n</code></pre> <p>It is called in-place because the list before and after have the same id, i.e., they correspond to the same object. One must be careful while using methods that perform operations in-place. A common error is to do something like this:</p> <pre><code>L = [1, 2, 3, 4, 5]\nL = L.reverse()\nprint(L)\n</code></pre> <p>This prints <code>None</code>, which is expected as <code>reverse</code> doesn't return a list. But sometimes, one may want to hold on to the original copy as well as its reverse. In such cases, we could do the following:</p> <pre><code>L = [1, 2, 3, 4, 5]\nL_reversed = L.copy()\nL_reversed.reverse()\nprint('Original list:', L)\nprint('Reversed list:', L_reversed)\n</code></pre> <p>Why did we have to make a copy in line 2?</p>"},{"location":"Notes/Section%205/Chapter%203/#sort","title":"sort","text":"<p>Another useful method is <code>sort</code>, which is used to sort lists in-place:</p> <pre><code>L = [2, 1, 5, 6, 4, 3]\nprint('Before', L)\nL.sort()\nprint('After', L)\n</code></pre> <p>Though this appears to be such a simple function to call, sorting is a non-trivial algorithm. We will be studying various algorithms to sort a sequence of items in the next course on data structures and algorithms.</p>"},{"location":"Notes/Section%205/Chapter%203/#remove","title":"remove","text":"<p>Now for some destructive functions:</p> <pre><code>L = [1, 2, 3, 4, 5] * 2\nprint('Before', L)\nL.remove(1)\nprint('After', L)\n</code></pre> <p><code>L.remove(x)</code> removes the first (leftmost) occurrence of the element x in the list L. Trying to remove an element that is not there in the list will raise a <code>ValueError</code> with the message <code>list.remove(x): x not in list</code>. A safe way to remove items is as follows:</p> <pre><code># x is the item to be removed; L is the list\nif x in L:\n    L.remove(x)\n</code></pre> <p>How is <code>remove</code> different from <code>pop</code>?</p>"},{"location":"Notes/Section%205/Chapter%203/#stack","title":"Stack","text":"<p>A list along with the methods <code>append</code> and <code>pop</code> simulates a data structure called a stack. A stack is a storage mechanism where the last item added to it is the first item to be removed. This is analogous to a stack of books. The topmost book in the stack is the most recent addition. When we want to remove books from this stack, the topmost book is the first to be removed. There is a catchy mnemonic for this, LIFO: Last In First Out.</p> <pre><code># Start with an empty stack\nstack = []\n# Append items to the end of the stack; also called a push operation\nstack.append('Harry Potter and the Philosopher\\'s Stone')\nstack.append('Harry Potter and the Chamber of Secrets')\n# State of the stack\nprint(stack)\n# Remove items from the end of the stack; also called a pop operation\nstack.pop()\n# State of the stack\nprint(stack)\n</code></pre>"},{"location":"Notes/Section%205/Chapter%203/#queue","title":"Queue","text":"<p>A list along with the methods <code>insert</code> and <code>pop</code> simulates a data structure called a queue. A queue is a storage mechanism where the first item added to it is the first to be removed. This is analogous to any queue that we encounter in real life, say at a billing counter. The first person to stand in the queue is the first to be served, and naturally the first to exit the queue. The mnemonic for this is FIFO: First In First Out.</p> <pre><code># Start with an empty queue\nqueue = []\n# Insert elements at the beginning of the queue\nqueue.insert(0, 'Customer-1')\nqueue.insert(0, 'Customer-2')\n# State of the queue\nprint(queue)\n# Remove items from the queue\nqueue.pop()\n# State of the queue\nprint(queue)\n</code></pre>"},{"location":"Notes/Section%205/Chapter%203/#strings-and-lists","title":"Strings and Lists","text":""},{"location":"Notes/Section%205/Chapter%203/#split","title":"split","text":"<p>Lists make a frequent appearance while processing strings. Consider the following problem:</p> <p>Accept a sentence as input and find the number of words in it. Assume that it is a simple sentence with a single space separating consecutive words. There are no other punctuation marks in the sentence.</p> <p>Let us look at a \"list-less\" solution first:</p> <p>Solution-1</p> <pre><code>sentence = 'this sentence is false' # a simple sentence\ncount = 1\nfor char in sentence:\n    if char == ' ':\n        count += 1\nprint(count)\n</code></pre> <p>We just scanned the sentence character by character and checked the number of spaces. The total number of words is one more than the number of spaces. As an aside, the sentence that we are dealing with is an example of a paradoxical statement. It can't be true or false: if it is true then it is false, if it is false then it is true! Back to Python, we shall look at the solution that uses lists.</p> <p>Solution-2</p> <pre><code>sentence = 'this sentence is false' # a simple sentence\nwords = sentence.split(' ')         # space is the delimiter used\ncount = len(words)\nprint(count)\n</code></pre> <p><code>split</code> is a string method that splits a string along a delimiter. A delimiter string is one or more characters that specify where to split the string. The output of the split operation is a list of strings that are split along the delimiter. If we print the list <code>words</code>, we get the following list: <code>['this', 'sentence', 'is', 'false']</code>. Let us take another example:</p> <pre><code>comma_words = 'one,two,three,four'\nnumbers = comma_words.split(',')\nprint(numbers)\n</code></pre> <p>We get <code>['one', 'two', 'three', 'four']</code> as the output. Note that we have specified <code>','</code> as the delimiter. The delimiter is not limited to characters; it can be any string. For example:</p> <pre><code>some_string = 'allISwell'\nwords = some_string.split('IS')\nprint(words)\n</code></pre> <p>The output is: <code>['all', 'well']</code>.</p>"},{"location":"Notes/Section%205/Chapter%203/#join","title":"join","text":"<p>Just as we went from a string to a list, we can also move from a list of strings to a string. Consider the following problem:</p> <p>Accept a sequence of words as input and construct a sentence out of it.</p> <p>We will first look at a solution that doesn't use lists:</p> <p>Solution-1</p> <pre><code>words = ['this', 'sentence', 'is', 'false']\nsentence = ''\nfor word in words:\n    sentence += word + ' '\nprint(sentence)\n</code></pre> <p>Though this solution seems correct, it is wrong by one character! Print the last character in the sentence:</p> <pre><code>print(sentence[-1])\n</code></pre> <p>It is not the letter e but a space. We ended up printing an extra space</p> <p>at the end. To avoid this issue, let us try another method that makes use of lists:</p> <p>Solution-2</p> <pre><code>words = ['this', 'sentence', 'is', 'false']\nsentence = ' '.join(words)\nprint(sentence)\n</code></pre> <p><code>join</code> is a string method that takes a list of strings and concatenates them together into a single string using a separator string. In our case, the separator is a space. The output is now as expected.</p>"},{"location":"Notes/Section%205/Chapter%203/#summary","title":"Summary","text":"<ul> <li>Lists are mutable sequences that can hold items of any type.</li> <li>Elements can be added, removed, and accessed using their index.</li> <li><code>append</code>, <code>insert</code>, <code>pop</code>, <code>remove</code>, <code>reverse</code>, and <code>sort</code> are useful list methods.</li> <li>Lists can simulate other data structures like stacks and queues.</li> <li>Strings can be split into lists and joined back into strings using <code>split</code> and <code>join</code>.</li> </ul>"},{"location":"Notes/Section%205/Chapter%204/","title":"Nested Lists","text":"<p>Recall the runs list that we generated with the help of the random library:</p> <pre><code>import random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6],\n                      weights=[30, 30, 20, 5, 10, 0, 5],\n                      k=120)\nassert len(runs) == 120\n</code></pre> <p>An assert statement is used whenever we wish to verify if some aspect of our code is working as intended. For example, in line 5 of the code given above, we are making sure that the length of the list is 120. This is a useful check to have as subsequent computation will depend upon this. If the conditional expression following the assert keyword is True, then control transfers to the next line. If it is False, the interpreter raises an <code>AssertionError</code>.</p> <p>Let us look at a different way of organizing the information contained in runs:</p> <pre><code>overs = list()\nnew_over = list()\nfor ball, run in enumerate(runs):\n    new_over.append(run)\n    if (ball + 1) % 6 == 0:\n        overs.append(new_over)\n        new_over = list()\n</code></pre> <p><code>overs</code> is a nested list, which is nothing but a list of lists. Each element in <code>overs</code> corresponds to an over in the match and is represented by a list that contains the runs scored in that over. The following code does a quick check if the sizes of the outer and inner lists are 20 and 6 respectively.</p> <pre><code>assert len(overs) == 20\nfor over in overs:\n    assert len(over) == 6\n</code></pre> <p>With this representation in place, how many runs were scored in the fourth ball of the third over?</p> <pre><code>answer = overs[2][3]    # zero-indexing\nprint(answer)\n</code></pre> <p>The first index corresponds to the outer list while the second index corresponds to the inner list. If this is still confusing, print the following code to convince yourself:</p> <pre><code>third_over = overs[2]\nprint(third_over)\nfourth_ball = third_over[3]\nprint(fourth_ball)\nassert fourth_ball == overs[2][3]\n</code></pre>"},{"location":"Notes/Section%205/Chapter%204/#matrices","title":"Matrices","text":"<p>Matrices are 2D objects. We can represent them as nested lists. Let us first populate a matrix of zeros:</p> <pre><code>mat = []\nfor i in range(3):\n    mat.append([])     # we are appending an empty list\n    for _ in range(3):\n        mat[i].append(0)\nprint(mat)\n</code></pre> <p>This gives the following output:</p> <pre><code>[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n</code></pre> <p>Do you find anything odd in line 4? We have used <code>_</code> as a loop variable. The inner-loop variable is insignificant and never gets used anywhere. As a convention, we use <code>_</code> to represent such variables whose sole purpose is to uphold the syntax of the language. Let us now construct another matrix:</p> <pre><code>mat = []\nnum = 1\nfor i in range(3):\n    mat.append([])\n    for _ in range(3):\n        mat[i].append(num)\n        num += 1\nprint(mat)\n</code></pre> <p>This gives the following output:</p> <pre><code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n</code></pre> <p>The code given above to construct this matrix could be written in the following manner as well:</p> <pre><code>mat = []\nnum = 1\nfor _ in range(3):\n    row = []\n    for _ in range(3):\n        row.append(num)\n        num += 1\n    mat.append(row)\nprint(mat)\n</code></pre>"},{"location":"Notes/Section%205/Chapter%204/#shallow-and-deep-copy","title":"Shallow and Deep Copy","text":"<p>Consider the following code:</p> <pre><code>mat1 = [[1, 2], [3, 4]]\nmat2 = mat1\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\n</code></pre> <p>We already know what will happen here. Lists are mutable. <code>mat2</code> is just an alias for <code>mat1</code>, and both point to the same object. Modifying any one of them will modify both. We also saw three different methods to copy lists so that modifying one doesn't modify the other. Let us try one of them:</p> <pre><code>mat2 = mat1.copy()\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\n</code></pre> <p>No problems so far. But try this:</p> <pre><code>mat1 = [[1, 2], [3, 4]]\nmat2 = mat1.copy()\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\n</code></pre> <p>This is the output we get:</p> <pre><code>[[100, 2], [3, 4]]\n[[100, 2], [3, 4]]\n</code></pre> <p>What is happening here? <code>mat1</code> has also changed! Wasn't <code>copy</code> supposed to get rid of this difficulty? We have a mutable object inside another mutable object. In such a case, <code>copy</code> just does a shallow copy; only a new outer-list object is produced. This means that the inner lists in <code>mat1</code> and <code>mat2</code> are still the same objects:</p> <pre><code>print(mat1[0] is mat2[0])\nprint(mat1[1] is mat2[1])\n</code></pre> <p>Both lines print <code>True</code>. In order to make a copy where both the inner and outer lists are new objects, we turn to <code>deepcopy</code>:</p> <pre><code>from copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\n</code></pre> <p>This gives the output:</p> <pre><code>[[1, 2], [3, 4]]\n[[100, 2], [3, 4]]\n</code></pre> <p>Finally, we have two completely different objects:</p> <pre><code>from copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nprint(mat1 is not mat2)\nprint(mat1[0] is not mat2[0])\nprint(mat1[1] is not mat2[1])\n</code></pre> <p>All three print <code>True</code>! <code>deepcopy</code> is a function from the library <code>copy</code>. We won't enter into how it works. Suffice to say that when using nested lists or any collection of mutable objects, use <code>deepcopy</code> if you wish to make a clean copy.</p>"},{"location":"Notes/Section%205/Chapter%205/","title":"Tuples","text":""},{"location":"Notes/Section%205/Chapter%205/#introduction","title":"Introduction","text":"<p>A tuple is an immutable sequence of values:</p> <pre><code>family = ('father', 'mother', 'child')\nprint(type(family))  # &lt;class 'tuple'&gt;\nprint(isinstance(family, tuple))  # True\n</code></pre> <p>Tuples resemble lists in that they can be indexed and sliced:</p> <pre><code>print(family[0])  # 'father'\nprint(family[:2])  # ('father', 'mother')\n</code></pre> <p>The key difference between lists and tuples is that tuples cannot be updated in-place due to their immutability. Therefore, the following operation will raise an error:</p> <pre><code>##### Alarm! Wrong code snippet! #####\nnumbers = ('one', 'two', 'four')\nnumbers[2] = 'three'  # TypeError: 'tuple' object does not support item assignment\n##### Alarm! Wrong code snippet! #####\n</code></pre> <p>As a result, elements in a tuple cannot be appended, inserted, or deleted. The only methods defined for tuples are <code>count</code> and <code>index</code>, which function as expected:</p> <pre><code>numbers = (1, 2, 3, 1, 1)\nprint(numbers.count(1))  # 3\nprint(numbers.index(2))  # 1\n</code></pre> <p>We can iterate through a tuple using a for loop:</p> <pre><code>for num in (1, 2, 3):\n    print(num)\n</code></pre> <p>Since tuples are immutable, they are passed by value in functions, similar to other immutable types like strings and numbers. Useful functions for tuples include <code>sum</code>, <code>max</code>, and <code>min</code>.</p>"},{"location":"Notes/Section%205/Chapter%205/#more-on-tuples","title":"More on Tuples","text":"<p>Here are some additional points about tuples:</p> <ul> <li>A singleton tuple should be defined with a comma:</li> </ul> <pre><code>i_am_single = (1,)\nprint(len(i_am_single))  # 1\nprint(isinstance(i_am_single, tuple))  # True\n</code></pre> <p>If the comma is removed:</p> <pre><code>i_am_single = (1)\nprint(isinstance(i_am_single, int))  # True\n</code></pre> <ul> <li>A list can be converted into a tuple, and vice versa:</li> </ul> <pre><code>a_list = [1, 2, 3]\na_tuple = tuple(a_list)  # (1, 2, 3)\nb_tuple = (1, 2, 3)\nb_list = list(b_tuple)  # [1, 2, 3]\n</code></pre> <ul> <li>A tuple can hold a non-homogeneous sequence of items:</li> </ul> <pre><code>a_tuple = (1, 'cool', True)\n</code></pre> <ul> <li>Membership can be checked using the <code>in</code> keyword:</li> </ul> <pre><code>1 in (1, 2, 3)  # True\n'hello' not in ('some', 'random', 'sequence')  # True\n</code></pre> <ul> <li>Tuples can be nested:</li> </ul> <pre><code>a = ((1, 2, 3), (4, 5, 6))\nprint(a[0][2])  # 3\n</code></pre> <ul> <li>A tuple can hold mutable objects:</li> </ul> <pre><code>a_tuple = ([0, 1, 2], [4, 5, 6])\na_tuple[0][0] = 100  # Runs without error\n</code></pre> <p>Although <code>a_tuple</code> is immutable, the elements inside it are mutable. We can verify that the identity of the element remains unchanged:</p> <pre><code>a_tuple = ([0, 1, 2], [4, 5, 6])\nprint(id(a_tuple[0]))  # ID of the first element\na_tuple[0][0] = 100\nprint(id(a_tuple[0]))  # Same ID as before\n</code></pre> <p>This shows that while the values inside mutable objects can change, their identities remain the same.</p>"},{"location":"Notes/Section%205/Chapter%205/#lists-and-tuples-comparison","title":"Lists and Tuples Comparison","text":"<p>Here\u2019s a brief summary highlighting the similarities and differences between lists and tuples:</p> List Tuple Mutable Immutable <code>L = [1, 2, 3]</code> <code>T = (1, 2, 3)</code> Supports indexing and slicing Supports indexing and slicing Supports item assignment Doesn't support item assignment Supported methods: <code>count</code>, <code>index</code>, <code>append</code>, <code>insert</code>, <code>remove</code>, <code>pop</code>, and others Supported methods: <code>count</code>, <code>index</code> To get a list: <code>list(obj)</code> To get a tuple: <code>tuple(obj)</code> <p>The relationship between lists and tuples can be further illustrated with an example of populating a list with ordered pairs of positive integers whose product is 100:</p> <pre><code>pairs = []\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            pairs.append((a, b))\nprint(pairs)\n</code></pre> <p>Here, <code>pairs</code> is a list of tuples. Using tuples is preferable because the two elements in each pair have a well-defined relationship, and we want to avoid accidental modifications.</p>"},{"location":"Notes/Section%205/Chapter%205/#packing-and-unpacking","title":"Packing and Unpacking","text":"<p>Despite seeming redundant, tuples play a significant role in Python. For example:</p> <pre><code>T = 1, 2, 3\nprint(T)  # (1, 2, 3)\nprint(isinstance(T, tuple))  # True\n</code></pre> <p>This is an example of tuple packing where the values 1, 2, and 3 are packed into a tuple. The reverse operation, sequence unpacking, is demonstrated as follows:</p> <pre><code>x, y, z = T\nprint(x, y, z)  # 1 2 3\n</code></pre> <p>Multiple assignment combines tuple packing and sequence unpacking:</p> <pre><code>x, y, z = 1, 2, 3  # Packs (1, 2, 3) and unpacks to x, y, z\n</code></pre> <p>Any sequence can be unpacked:</p> <pre><code>l1, l2, l3, l4 = 'good'  # string\nnum1, num2, num3 = [1, 2, 3]  # list\nb1, b2 = (True, False)  # tuple\nx, y, z = range(3)  # range\n</code></pre> <p>This functionality also applies when multiple values are returned from functions:</p> <pre><code>def max_min(a, b):\n    if a &gt; b:\n        return a, b\n    return b, a\n\nx = max_min(1, 2)\nprint(x)  # (2, 1)\nprint(isinstance(x, tuple))  # True\n</code></pre> <p>In the return statements, the multiple values are packed into a tuple, demonstrating how functions can return tuples.</p>"}]}